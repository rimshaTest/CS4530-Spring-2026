{"0": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "Activity 1: User Stories and Conditions of Satisfaction",
    "content": "Introduction . This activity will give you practice with using user stories to solicit and document user requirements, refining them into conditions of satisfaction, and assigning priorities. Before you start, be sure to review the tutorial “User Stories and Conditions of Satisfaction” on the course website. Scenario . Consider a Learning Management System (like Canvas). Choose one of the following areas: . | Sections and Enrollment | Assignment Submission and Grading | Gradebooks | . Requirements for this activity . | Say which area you picked. | Identify at least 3 different roles representing different classes of users for that area. | Choose one of those roles and write down at least 3 different user stories for that participant. These should be of the form . As a &lt;role&gt; I want &lt;some capability&gt; so that I can &lt;get some benefit&gt; . | For each user story, write 3-4 conditions of satisfaction with appropriate priorities. (Essential = user story is not satisfied without it). There must be at least one essential condition of satisfaction and least one non-essential condition of satisfaction. | . Please submit a total of: . | 1 area | 3 roles | 3 user stories | 9-12 conditions of satisfaction with priorities | . When you are done, submit your work as required by your instructor (check the Canvas asssignment for details, if assigned). This may vary from section to section. Grading Criteria: 10pts . | 3 roles (3 pts) | 3 user stories (3 pts) | 9-12 conditions of satisfaction with appropriate priorities (4 pts) | . ",
    "url": "/CS4530-Spring-2026/Activities/Module01%20Activity/#activity-1-user-stories-and-conditions-of-satisfaction",
    
    "relUrl": "/Activities/Module01%20Activity/#activity-1-user-stories-and-conditions-of-satisfaction"
  },"1": {
    "doc": "User Stories and Conditions of Satisfaction",
    "title": "User Stories and Conditions of Satisfaction",
    "content": " ",
    "url": "/CS4530-Spring-2026/Activities/Module01%20Activity/",
    
    "relUrl": "/Activities/Module01%20Activity/"
  },"2": {
    "doc": "Test-Driven Development",
    "title": "Activity: Test-Driven Development",
    "content": "This activity is intended to supplement the CS4530 lecture on test-driven development. You will need to have already completed the development environment setup for the class. Steps . | Get the starter code by cloning the transcript-service-m02 repository from GitHub | Run npm install inside the directory that is created when you unzip the download. | Check that every member of the group can run . npx vitest --run src/types.spec.ts . and see one failing and one passing test. | Check that every member of the group can run . npx vitest --run src/transcript.service.spec.ts . and see five passing tests. | Check that every member of the group can run . npm run test . to run Vitest on all the test files simultaneously and see six passing tests and one failing test. | Check that every member of your group can see the ESLint error in src/transcript.service.ts. Discuss how to fix the error. | Write down two testable behaviors for the addGrade function corresponding to the condition of satisfaction that “the user can add a new grade for an existing student.” These should be written as it(\"&lt;testable beahvior&gt;\", () =&gt; {}) in src/transcript.service.spec.ts. | Come up with at least two ways in which the addGrade function isn’t completely specified by the conditions of satisfaction given in lecture. Document these as comments in src/transcript.service.spec.ts. These tests will fail, because addGrade is not implemented. You are not required to implement or submit addGrade. | Add Vitest tests to your testable behaviors in src/transcript.service.spec.ts. (There should be at least four new tests for addGrade at this point.) . | When you are done, submit the modified src/transcript.service.spec.ts file as required by your instructor. | . Grading Rubric: . Grading will be done via “specification grading”. There are only two non-zero grades: Satisfactory (10 points), and Minimal (5 points). To obtain a grade of Satisfactory, you must deliver all of the requirements listed in the instructions. To obtain a grade of Minimal, you must have at least two meaningful tests for addGrade in src/transcript.service.spec.ts. Grading will be manual; the TAs will look at your solution; they may or may not run them. ",
    "url": "/CS4530-Spring-2026/Activities/Module02%20Activity/#activity-test-driven-development",
    
    "relUrl": "/Activities/Module02%20Activity/#activity-test-driven-development"
  },"3": {
    "doc": "Test-Driven Development",
    "title": "Test-Driven Development",
    "content": " ",
    "url": "/CS4530-Spring-2026/Activities/Module02%20Activity/",
    
    "relUrl": "/Activities/Module02%20Activity/"
  },"4": {
    "doc": "Policy on Use of AI",
    "title": "Policy on use of AI",
    "content": "Our policy on use of AI can be found below: . For all written work: . We ask for written reflections to understand your own thought process and practice communication, not because we want to read lots of LLM output. Please show respect and do not use LLM-based tools to generate your written assignments. For IP1, IP2, and Activities: . The use of Artificial Intelligence (AI) tools is forbidden. | This includes the use of Copilot or other tools that suggest the next line or few lines of code. | This includes use of tools that take natural-language input and generate code such as Chat GPT, Cursor, AugmentCode, Chat modes in VSC, and “/” commands in CoPilot | This includes chat based tools that allow you to ask questions about your code (“where is the controller for the /user/ API endpoint”). | . You may use LLM-based tools like ChatGPT or Claude as shortcuts in situations where you might use Google Search, Stack Overflow, etc, for learning purposes only. You may never copy-paste code produced by online resources. Remember: The basic policy is that you are responsible for the code you submit. We reserve the right to interview you orally to make sure that you understand everything in your submission. For IP3 and the Team Project: . The following policy is a draft. We solicit feedback from students who have already used AI tools in their programming. The use of Artificial Intelligence (AI) tools is permitted, subject to the following: . | The basic policy is that you are responsible for the code you contribute to the project, and you are responsible for the code you review in the project. Telling a groupmate or course staff member “I don’t know, it’s what the AI produced” or “I don’t know, the AI said it made sense” is not in line with the minimal expectations of the course, and repeatedly failing to be accountable for the code you write or the code reviews you sign off on will result in failing the course. We reserve the right to interview you orally to make sure that you understand everything in your submission. | Each team should have a common policy about the use of AI in their project. It is not fair for one team member to be using AI, and the others not (or vice versa). Your team policy should take into account the relative experiences of the team members with AI coding tools. | You will still have to debug your code and tests. These models are trained mostly on code that works, so they are generally bad at debugging code they have never seen before. If you don’t understand the code, then you will not be able to debug it, nor will your TA be able to help you. | Any monetary costs associated with these tools are to be borne by the student (sorry). We encourage students to share information about available student discounts. | Do your own reflections, assessments, and reports. The point of reflections is what happens in your brain, not in producing text that course staff gets to read. | . If you do use such a tool, here are a few suggestions: . | Don’t ask to go far beyond what you can review and understand as you go. Remember, you are ultimately responsible for the code | “Vibe” coding, in which the AI writes large chunks of code without supervision, is strongly discouraged. (see bullet above about your personal responsibility for the code). | Beware letting the chatbot lead you on wild goose chases if the first or second suggestion doesn’t nail the problem. | Treat it like a very junior (but over-eager) engineer, who needs constant supervision and frequent correction. | Use rules (like .cursorrules) to set the ground rules for the AI. There are lots of sources for useful sets of rules. We encourage you to share such rulesets, both within your team and with other students in the course. (And with the course staff: we want to learn, too!) | . ",
    "url": "/CS4530-Spring-2026/policies/ai#policy-on-use-of-ai",
    
    "relUrl": "/policies/ai#policy-on-use-of-ai"
  },"5": {
    "doc": "Policy on Use of AI",
    "title": "Policy on Use of AI",
    "content": " ",
    "url": "/CS4530-Spring-2026/policies/ai",
    
    "relUrl": "/policies/ai"
  },"6": {
    "doc": "Announcements",
    "title": "Announcements",
    "content": " ",
    "url": "/CS4530-Spring-2026/announcements/",
    
    "relUrl": "/announcements/"
  },"7": {
    "doc": "Announcements",
    "title": "Welcome to CS4530 - Spring 2026",
    "content": "Jan 6 &middot; 1 min read On behalf of the entire instructional team (all 3 instructors and 18 TAs), welcome to the Spring 2026 edition of CS 4530! This website will contain all of the lectures, assignments and tutorials for the class. Our Canvas site contains your gradebook as well as single-sign-on links to Piazza (for questions and discussion), instructions for submitting assignments and replicates much of the material from the class website. In advance of the first week of class, we’ve shared the calendars for each section, the first two lectures (with related activities), and tutorials on installing your IDE, Typescript, Unit testing with Vitest, and API Requests. The first individual project deliverable will also be posted shortly. This deliverable will be due on Wednesday January 21st 11am EST. Your work will be submitted through github Classroom and Gradescope. Tomorrow afternoon (i.e., first day of classes), we will be adding all enrolled students to our github organization (and you will be receving an invitation by email). Once you have accepted that, you will be be able to start working on IP1, which we would encourage you to do early. Feel free to use piazza to ask questions and use office hours if you need help. The schedule of office hours will be posted on the staff page tomorrow. We will start holding office hours from Thursday Jan 8th and we will have 70+ hours of scheduled TA office hours per week. Zoom link for the online section (Section 4) can be found on Canvas -&gt; Zoom Meetings. We are looking forward to meeting you all this week! . ",
    "url": "/CS4530-Spring-2026/announcements/",
    
    "relUrl": "/announcements/"
  },"8": {
    "doc": "Announcements",
    "title": "Initial Website Launched",
    "content": "Nov 18 &middot; 0 min read Welcome to the course website for CS4530, Spring 2026! Over the coming weeks, we will be populating this website (and Canvas) with more information about the course. ",
    "url": "/CS4530-Spring-2026/announcements/",
    
    "relUrl": "/announcements/"
  },"9": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": " ",
    "url": "/CS4530-Spring-2026/assignments/",
    
    "relUrl": "/assignments/"
  },"10": {
    "doc": "Debugging",
    "title": "Debugging",
    "content": "One of the objectives of this class is to provide students with experiences writing new code for large, existing codebases. We anticipate that you may run into difficulties debugging the project code: it is often difficult to build debugging skills until you have a problem in front of you that requires them. The course staff is happy to help you with debugging, with the specific goal of helping you learn to successfully apply scientific debugging. Andreas Zeller’s Debugging Book provides an excellent guide to scientific debugging. The short version is roughly: if you can’t debug an issue in the first few minutes “just by looking at it”, it will be hard to keep all of the relevant information in your head at once, and a formal process to help you generate and refine guesses for why something is wrong can be immensely useful. The key idea is to create a debugging note file, where you track information like: . | What was the input/application state that caused the bug? | What was the behavior that I expected? | What was the behavior that I observed? | What are possible hypotheses for that behavior? | How have I tested those hypotheses, and what was the result? | . The overall goal with hypothesis formulation is to come up with possible causes for why the bug exists. Then, as long as those hypotheses are testable, we can prove or disprove them. Most hypotheses will be along the lines of “did I make an incorrect assumption about how a library or API works.” The devil is in enumerating all of the possible incorrect assumptions that you might have made, and testing them. The best way to attack these kinds of problems is to start with testing some high-level, general assumptions, and then refine them. If you come to us for debugging help, we will ask you to answer these 5 questions, as our goal is to help you get better at debugging and not to simply point out bugs that we might have seen before. We are happy to discuss the problematic behavior that you are observing, possible hypotheses for why that behavior is occurring, and strategies to test those hypotheses. In the past, students have found that using a variety of strategies to test their hypotheses (e.g. using a debugger, creating a minimized test case, measured application of console.log statements, internet research) are useful, and we would be happy to demonstrate these. We may not be able to stay with you while you work on refining your hypotheses and fixing the bug, but would be happy to continue following up if you get stuck again. ",
    "url": "/CS4530-Spring-2026/policies/debugging/",
    
    "relUrl": "/policies/debugging/"
  },"11": {
    "doc": "CS4530, Spring 2026",
    "title": "CS4530, Spring 2026: Fundamentals of Software Engineering",
    "content": " ",
    "url": "/CS4530-Spring-2026/#cs4530-spring-2026-fundamentals-of-software-engineering",
    
    "relUrl": "/#cs4530-spring-2026-fundamentals-of-software-engineering"
  },"12": {
    "doc": "CS4530, Spring 2026",
    "title": "Welcome to CS4530 - Spring 2026",
    "content": "Jan 6 &middot; 1 min read On behalf of the entire instructional team (all 3 instructors and 18 TAs), welcome to the Spring 2026 edition of CS 4530! This website will contain all of the lectures, assignments and tutorials for the class. Our Canvas site contains your gradebook as well as single-sign-on links to Piazza (for questions and discussion), instructions for submitting assignments and replicates much of the material from the class website. In advance of the first week of class, we’ve shared the calendars for each section, the first two lectures (with related activities), and tutorials on installing your IDE, Typescript, Unit testing with Vitest, and API Requests. The first individual project deliverable will also be posted shortly. This deliverable will be due on Wednesday January 21st 11am EST. Your work will be submitted through github Classroom and Gradescope. Tomorrow afternoon (i.e., first day of classes), we will be adding all enrolled students to our github organization (and you will be receving an invitation by email). Once you have accepted that, you will be be able to start working on IP1, which we would encourage you to do early. Feel free to use piazza to ask questions and use office hours if you need help. The schedule of office hours will be posted on the staff page tomorrow. We will start holding office hours from Thursday Jan 8th and we will have 70+ hours of scheduled TA office hours per week. Zoom link for the online section (Section 4) can be found on Canvas -&gt; Zoom Meetings. We are looking forward to meeting you all this week! . Announcements . ",
    "url": "/CS4530-Spring-2026/",
    
    "relUrl": "/"
  },"13": {
    "doc": "CS4530, Spring 2026",
    "title": "Overview",
    "content": "Building, delivering and maintaining successful software products requires more than being good at programming. Software engineering encompasses the tools and processes that we use to design, construct and maintain programs over time. Software engineering has been said to consider the “multi person development of multi version programs.” Development processes that work well for a single developer do not scale to large or even medium-sized teams. Similarly, development processes that work well for quickly delivering a one-off program to a client cause chaos when applied to a codebase that needs to be maintained and updated over months and years. This class will begin to explore these tradeoffs throughout the entire software development lifecycle, with a particular focus on how these decisions affect the quality of the resulting software. This class will serve as an introduction to the field of software engineering, covering key topics such as: . | Requirements gathering and specification How to make sure that you build the product that your customer really wants | Designing code for reuse, for readability, and for scale How to avoid reinventing the wheel? What makes code readable? Where does performance fit into designs? When do we decide when to revisit old design decisions, and how do we replace them? Can we avoid the mistakes that past developers have made? | How to organize your development process to collaborate effectively How do we communicate our designs with others? How do we structure and coordinate development activities? How do we measure the performance of these processes, and tweak them over time? | How to ensure that your code works, is secure, and broadly speaking, “does the right thing” How do we measure different quality attributes like usability, scalability and performance? How do we minimize the cost of defects? How do we automatically test complex systems? Can we automatically prove the absence of some kinds of defects? | . ",
    "url": "/CS4530-Spring-2026/#overview",
    
    "relUrl": "/#overview"
  },"14": {
    "doc": "CS4530, Spring 2026",
    "title": "Course Outcomes",
    "content": ". | Students will be able to define and describe the phases of the software engineering lifecycle (requirements, design, implementation, testing, deployment, maintenance) | Students will be able to explain the role of key processes and technologies in modern software development. | Students will be able to productively apply instances of major tools used in elementary SE tasks. | Students will design and implement a portfolio-worthy software engineering project in a small team environment that can be publicly showcased to recruiters. | . Course Delivery . The course will be delivered in a “traditional” lecture style. Prof Wand’s section will be entirely virtual, and the other sections will be entirely on-the-ground, with no virtual participation option. You must attend the section for which you have registered, and you may not partner with students in other sections for the term project. | Section | Instructor | Meeting Time | Meeting Place | . | 1 | Prof Bhutta | MR 11:45 am - 1:25 pm | West Village H 108 | . | 2 | Prof Bhutta | TF 9:50 am - 11:30 am | EXP 201 | . | 3 | Prof Bhutta | T 11:45 am - 1:25 pm &amp; R 2:50 pm - 4:30pm | West Village H 110 | . | 4 | Prof Wand | W 6:00 pm - 9:20 pm | Online | . | 5 | Prof Simmons | WF 11:45 am - 1:25 pm | West Village H 110 | . | 6 | Prof Simmons | TF 3:25 pm - 5:05 pm | West Village H 110 | . ",
    "url": "/CS4530-Spring-2026/#course-outcomes",
    
    "relUrl": "/#course-outcomes"
  },"15": {
    "doc": "CS4530, Spring 2026",
    "title": "Course Project",
    "content": "The assignments and project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement new features. The codebase that we’ll be developing on is a Fake Stack Overflow project. You will get an opportunity to work with the starter code which provides basic skeleton for the app and then additional features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. At the end of the semester, the instructors and TAs will evaluate all of the student projects, and select the best (in terms of usability, code quality, test suite quality, and overall design) to showcase on course website. The project will provide hands-on experience to complement the skills taught in this class, requiring students to be able to: . | Work effectively in a small team | Enumerate and prioritize development tasks | Propose, design, implement and test new feature(s) in an existing non-toy software application | Write code that their team members can read and review | Review teammates’ code | Analyze a proposed software architecture | Use relevant software tools, such as: . | TypeScript | React | Visual Studio Code (or similar IDE) | Git | Vitest | Postman | . | . Select projects from Spring 2025 are hosted in our project showcase. Acknowledgements . This class and its contents were inspired by Software Engineering courses at various institutions, including: . | Columbia’s Software Engineering Course, COMS W4156 | CMU’s Software Engineering Course, 17-313 | GMU’s Web App Development Course, SWE 432 | NCSU’s Software Engineering Course, CSC 326 and its iTrust term project, also Chris Parnin’s DevOps course. | Past iterations of CS4530 at Northeastern: Fall 2025, Spring 2025, Fall 2024, Spring 2024, Fall 2023, Spring 2023, Fall 2022, Spring 2022, Spring 2021 | Past iterations of CS5500 at Northeastern, as prepared by Mike Weintraub, Mike Shah, Frank Tip and Joydeep Mitra (Spring 2024). | . This website is built using Kevin Lin’s Just the Class Jekyll template. ",
    "url": "/CS4530-Spring-2026/#course-project",
    
    "relUrl": "/#course-project"
  },"16": {
    "doc": "CS4530, Spring 2026",
    "title": "CS4530, Spring 2026",
    "content": " ",
    "url": "/CS4530-Spring-2026/",
    
    "relUrl": "/"
  },"17": {
    "doc": "Individual Project 1",
    "title": "Changelog",
    "content": ". | 2026-01-07: Clarified that all changes should be made to the main branch. | 2026-01-09: Clarification in Task 3, part 2: instead of “modify the tests,” say “improve existing tests and/or add new tests.” | 2026-01-10: Correction: AuthRecord is defined in server/src/models.ts, not in server/src/models/auth.model.ts. | 2026-01-11: Changed application tab to “Network” tab (the precise name may depend on the browser) in the Recommendations section. | . ",
    "url": "/CS4530-Spring-2026/assignments/ip1#changelog",
    
    "relUrl": "/assignments/ip1#changelog"
  },"18": {
    "doc": "Individual Project 1",
    "title": "1. Getting Started",
    "content": "If you were registered for the class before Wednesday, January 7, you should have an email from a TA with an invitation to our organization. Be sure to check your spam/junk folder. The first step is to accept the invitation. If you cannot find the invitation, if you registered for the class late, or have any other issue that keeps you from getting started, please create a Piazza post to contact us and we will try to help. After that, accept our GitHub Classroom Invitation for this assignment. It will create a Github repository for you which will include the starter code for this assignment. If you are new to Git, you may want to work on “Learning Basics of Git” assignment first! We expect all students to be able to use add/commit/push for their work. 1.1. Prerequisites . You’ll need to start by setting up your development environment, including node.js and npm. Next, make sure you have used Git to clone the starter code. This code is divided into 3 main directories: client, server, and shared. These are connected in a single NPM workspace, but you shouldn’t have to worry much about what that means. After that, follow the following steps: . | Navigate to the root directory of the repo. | Install the dependencies: . ip1-me $&gt; npm install . | Start the server: . ip1-me $&gt; cd server server $&gt; npm run dev . You should then be able to visit http://localhost:8000 and get a message that tells you that you should be looking at elsewhere for the Vite frontend. | Leave npm run dev running in the ./server directory for the next step. | Open a new terminal window and start Vite, and start the Vite development server using the following commands: . ip1-me $&gt; cd client client $&gt; npm run dev . This will give you a url to go to, probably http://localhost:4530/. If you see a login page, then you’re up and running. You can create a new user or use one of the four automatically-created username-password combinations: user0/pwd0000, user1/pwd1111, user2/pwd2222, or user3/pwd3333. | . 1.2. Understanding “The Server” . The code in the server directory is all TypeScript that is intended to be run on a web server. It’s built on top of express, a library used to create programs that accept and respond to HTTP requests. Express can do a lot of things, but we’re only using it to send and receive chunks of JSON-formatted data (line 19 of server/src/app.ts tells the Express library to behave that way). HTTP GET Requests . Your web browser makes one kind of HTTP request, a GET request, whenever you type in a URL and hit ENTER. If you go to http://localhost:8000/api/thread/list while the server is running, you will see a bunch of JSON-formatted data. Line 37 of server/src/app.ts causes the request to that URL to be sent to the getList controller, which is just a function that is defined in server/src/controllers/thread.controller.ts. HTTP GET requests are supposed to just look up information. It is considered bad behavior if a HTTP GET requests changes anything about the state of the world. (Creating a new account on a website, updating a password, sending a chat message, and or deleting a Google doc are all examples of changes to the state of the world; HTTP GET shouldn’t be able to trigger any of these changes.) In the context of GameNite, a HTTP GET request shouldn’t add a new comment, or create a new post, or initialize a new game. HTTP POST Requests . A HTTP POST request, on the other hand, sends information to a server and receives information in return; it may change things about the state of the world. You can make POST requests with a tool like Postman or from the command line with a tool like cURL. If you run this cURL command while the server is running, it will make a new post that you can see if you go to the website’s frontend. curl --location 'localhost:8000/api/thread/create' \\ --header 'Content-Type: application/json' \\ --data '{ \"auth\": { \"username\": \"user3\", \"password\": \"pwd3333\" }, \"payload\": { \"title\": \"New Post\", \"text\": \"Text goes here\" } }' . Line 36 of server/src/app.ts causes this request to be sent to the postCreate controller, which is also just a function defined in server/src/controllers/thread.controller.ts. You may find that it’s easier to make HTTP POST requests from a tool like Postman instead of writing curl commands directly. If you click the &lt;/&gt; icon in Postman while developing a request, you can pick “cURL” from the dropdown menu and get a command-line snippet that performs the same request. Other HTTP Requests . There is a whole vocabulary of HTTP requests, but the most important two for this class are GET and POST. There’s a whole vocabulary of HTTP requests that you can learn more about. 1.3. Understanding “The Client” . The code in the client directory is mostly TypeScript that is intended to be run in a web browser. But web browsers don’t know how to run TypeScript, they only know how to run JavaScript. While you’re working on a project, it’s important to be able to look at what your code is doing in a web browser, and when you’re done working on your project, all your code needs to be turned into a form that can get shipped to a web browser. GameNite uses Vite for this. Vite is a build tool — you use to preview the website you’re building, and you use it to build the final website that you ship to users. 1.4. Shared Code . The TypeScript types in the shared directory are used by both the client and the server. The data sent by HTTP POST request to create a post has the TypeScript type WithAuth&lt;CreateThreadMessage&gt;, which, if you look at shared/src/auth.types.ts and shared/src/thread.types.ts, you can see expands to this TypeScript interface: . type TypeOfPostRequest = { auth: { username: string; password: string; }; payload: { title: string; text: string; }; } . The client can use the WithAuth&lt;CreateThreadMessage&gt; type to ensure that it is sending a message with the right structure to the server. Because these types are described with zod schema validators, the server can use the same code to check that it received something with the right structure. (Usually the server gets things sent by the client, but as we saw, you can also use cURL to send random nonsense to the server. The server can’t trust anything about the structure of information it receives from a HTTP request!) . 1.5. Testing . Unit tests for the server are in server/tests/**/*.spec.ts. These are written in Vitest, a tool discussed in one of the first two lectures. (If you’ve used Jest, you should be good to go: Vitest is designed to be very similar.) . You can test the server by going to the server directory and running npm run test. It can be very helpful to have tests constantly re-running whenever you edit code, which you can do by running npm run vitest. ",
    "url": "/CS4530-Spring-2026/assignments/ip1#1-getting-started",
    
    "relUrl": "/assignments/ip1#1-getting-started"
  },"19": {
    "doc": "Individual Project 1",
    "title": "2. Recommendations When Working on the Project",
    "content": ". | Open the client application in a browser and interact with it. While interacting, monitor the “Network” tab (the precise name may depend on the browser) in your browser’s developer tools. This tab will give you information about the HTTP requests the client sends to the server. The HTTP requests will contain URIs in their headers. You can use this information to understand the endpoints in the server. | Make sure VS Code is set up as described in the development environment tutorial, with ESLint, Typescript, and Prettier installed. Our ESLint setup encodes very specific style rules, and if you do not have VSCode lint feedback enabled you will have to deal with an avalanche of errors when you first lint your code. | Do not wait until the last minute to run npm run lint and npm run build to check for linter and typescript errors! | Follow the debugging policy to help in the debugging process. | Frequently add and commit changes with git. This saves your changes and makes it easy to go back to a state where most tasks were complete. | . ",
    "url": "/CS4530-Spring-2026/assignments/ip1#2-recommendations-when-working-on-the-project",
    
    "relUrl": "/assignments/ip1#2-recommendations-when-working-on-the-project"
  },"20": {
    "doc": "Individual Project 1",
    "title": "3. Project Submission",
    "content": "You will submit your code by pushing the final version into your repository (add/commit/push). In this assignment, you should only be making, committing, and pushing changes to the main branch of your repository. Be sure to check if the correct version is submitted before the deadline. On Gradescope, you will submit a plain .txt file containing two things: . | The link to your project’s GitHub repo (e.g. https://github.com/neu-cs4530/ip1-robsimmons) | The written responses and cURL commands requested in Task 3. | . We will grade your code on GitHub by using the “Feedback” PR that is automatically created when the assignment is. The Feedback PR can be found under the “Pull requests” menu, like this: . If you don’t see your Feedback PR for the assignment, let us know on Piazza (be sure include your GitHub username). Grades will be assigned on Gradescope and synced to the Canvas Gradebook. TypeScript ESLint, Vitest, and Configuration Files . The GitHub project contains a number of configuration files you may not modify: package.json, package-lock.json, .prettierrc, tsconfig.json, vitest.config.mjs, and vite.config.mjs are configuration files, as is everything in the .github directory. If you change any of these files, take care to change them back; the list of changes in the feedback PR should not show any changes to these files. You also may not include eslint-disable commands to disable ESLint’s checks in your final submission. The code you submit must pass GitHub’s automatic checks, which mostly just amount to the TypeScript typechecker, the ESLint linter, and the tests. You can run these yourself like this: . ip1-me $&gt; npm run check --workspaces ip1-me $&gt; npm run lint --workspaces ip1-me $&gt; npm run test --workspaces . When you push your code to GitHub, you can see the status icon for your most recent submission. It’s initially a yellow circle, like this: . After the tests run, this will turn into a red ❌ or a green ✅. Clicking on the icon will let you see details of the tests we ran. The Actions tab on GitHub has the results of previous runs. Up to 25% of your total grade on the assignment may be deducted for CI failures (5% for prettier failures, 10% for TypeScript failures, and 10% for ESLint failures). In severe cases we may decline to grade your assignment entirely. Give yourself sufficient time to find and fix any errors. ESLint warnings do not cause CI to fail will not automatically lead to a deduction, but it is bad practice to have lots of console statements in your code, and this can lead to a point deduction if it makes it hard for a TA to understand your code. ",
    "url": "/CS4530-Spring-2026/assignments/ip1#3-project-submission",
    
    "relUrl": "/assignments/ip1#3-project-submission"
  },"21": {
    "doc": "Individual Project 1",
    "title": "4. Implementation Tasks",
    "content": "Task 1: Tic-Tac-Toe . You should try to start a game of Tic-Tac-Toe in the development server. (Log in as two different users in two different windows.) You should observe that other games work, but Tic-Tac-Toe does not! To make Tic-Tac-Toe work on GameNite, you’ll need to fill in the missing implementation in server/src/games/ticTacToe.ts. Places to look for guidance: . | The type specification for a game implementation in server/src/games/gameLogic.ts, explains what each unimplemented function does. | The types of Tic-Tac-Toe in shared/src/games/ticTacToe.ts, explain in detail how the game is intended to work. | The implementations of Nim and Guessing Game in the directory server/src/games, which may be a helpful basis for comparison. | . This task is worth 25 points: . | 15 points will be assigned automatically based on passing our test suite | 10 points will be assigned by TAs manually checking for issues with code style. Take care to document any helper functions you include. | . Task 2: Tests for Tic-Tac-Toe . The purpose of this part of the assignment is to get used to writing Vitest tests. (Copilot-esque LLM autocompletion is quite good at writing tests, and you’ll have a chance to try this out later in the class. If you have Copilot-style autocompletion enabled, you are violating the course’s academic integrity policy and risking a failing grade, and in addition, this task will be exceptionally pointless and boring.) . Write tests for Tic-Tac-Toe in a new file, server/tests/games/ticTacToe.spec.ts. Your tests should achieve full branch coverage on your own implementation of Tic Tac Toe: when you run npm run test in the server directory, Vitest should report no “Uncovered Line #s” in src/games/ticTacToe.ts. (You can also open the index.html file in the coverage folder that vitest creates when you run npm run test, which provides an easily readable coverage report.) There are other parts of the application that don’t have full coverage, but you only need to worry about coverage of the ticTacToe.ts implementation. Make sure to look at the tests for Nim and Guessing Game, they will provide an excellent guide. This task is worth 20 points: . | 5 points for having tests that reasonably test each of the main functions you have implemented | 5 points for following the format and style of the Nim and Guessing Game tests | 6 points for achieving full branch coverage for ticTacToe.ts (3 points for 90%+ branch coverage) | 4 points for your tests working against some of our custom “mutants” — your tests should not be overspecified (they should pass valid implementations of ticTacToe.ts that may be slightly different than your own), and they should correctly catch and fail implementations of Tic Tac Toe that have bugs. | . Watch out on Piazza — we will try to set up an autograder that optionally lets you test your tests against our mutants Tic Tac Toe implementations closer to the assignment deadline. We’ll also allow you to test your own Tic Tac Toe implementations, and reserve the right to give bonus points to anyone who can show a valid Tic Tac Toe implementation that fails our tests. Task 3: Exposing Errors in the User Service . There are several problems with the User service for GameNite. In the remainder of this assignment, you will begin addressing them. The first and most glaring is that some of the functions, despite claiming to return SafeUserInfo objects, actually return passwords, which are then passed on to the controller and returned. REST API calls should never expose passwords in their responses like this! . | Investigate the five User REST API endpoints listed in the README, the User controller in server/src/controllers/user.controller.ts, and the User service in server/src/services/user.service.ts, to find at least one way of exposing passwords through the API. In the written part of your submission, include a cURL command that result in the User API returning passwords. | It’s quite embarrassing that these bugs exist despite the user service having 100% test coverage! Here’s your chance to do test-driven development. First, improve existing tests and/or add new tests so that the test suite actually fails (as it should!) on the current implementation. The User record’s userId (a random id, not the username) and the password should never be exposed through REST API endpoints, and the tests should account for this requirement. Second, modify the user service so that it passes the new tests. | In the written part of your submission, briefly explain why TypeScript allowed a SafeUserInfo-returning service function to include a password field despite SafeUserInfo having no password field. | Challenge: there’s another definite bug in the user service that’s a little more difficult to find, but that could potentially represent a security issue. Identify the bug and include a cURL command that demonstrates it, explain why the cURL command demonstrates something bad happening, create a failing test, and fix the bug. (This is just worth 5% of the overall score for this assignment. Don’t get stuck here and neglect the other tasks!) . | . This task is worth 20 points: 5 points for each sub-part. Task 4: Creating an Auth model . There are two connected issues with the User model: . | There’s a frequent use of for-loops to loop through all the usernames to find a record that matches a specific username. | Storing authentication information like a password alongside user profile information like a display name is not a great design: it can make accidental leaks like the ones we’ve encountered more likely! | . These aren’t totally connected problems, but we can solve them together. The file server/src/services/user.service.ts contains an unused storedAuths object that you will use to maintain a mapping from valid usernames to the user IDs that let you look up profile information (like the display name) for that user. The AuthRecord type defined in server/src/models.ts also contains a password. Whenever you create a user, you’ll continue to create a new and random user ID, and add to storedUsers an entry that maps from the user ID to the user’s record. You should modify UserRecord to no longer contain a password, and ensure that the stored record does not contain a password. Additionally, when you create a user, you’ll add an entry to storedAuths that maps the username to the UserRecord. By using stored auth, you can find the user record associated with a username in two steps: find the user ID using storedAuths, and then find the user’s record with that ID in storedUsers. To complete this part, you should: . | Remove the password field from UserRecord, and instead | Maintain the property that whenever you have storedUsers[id] === user, then storedAuth[user.username].user === id. | Avoid having any functions in user.service.ts that loop over all elements in a JavaScript object in order to find one in particular. | Ensure that all tests still pass and that the tests still provide total branch coverage for the User service (user.service.ts. You don’t need to worry about coverage of other files. | . This task is worth 20 points, which will be assigned by manual grading: . | 5 points for correctly modifying the User and Auth records | 5 points for correctly updating document comments and documenting new | 5 points for ensuring that the stored User records and stored Auth records stay in sync | 5 points for ensuring that there are no functions that loop through all the usernames in order to find one in particular | . Task 5: Refactoring the Auth model . The purpose of this part of the assignment is to get your fingers comfortable with the functionality that TypeScript provides, and comfortable with seeing “red squiggly” errors in VSCode and then fixing them. (Again: if you use LLM or Copilot-powered autocompletion on this part, you are doing nothing but interfering with your own learning.) . Suggestion: if you haven’t added and committed your code with Git yet, you should do so now. This task has you making a lot of changes, and it may be helpful to be able to quickly go back to the code before you started making changes. You now have two different types of code mixed up in user.service.ts — code primarily concerned with authentication, and code primarily concerned with the user’s personal data. In this part, your goal is to move the following elements from user.service.ts to a new file, auth.service.ts: . | storedAuths (which should not be exported from auth.service.ts) | resetStoredAuth() | getUserByUser() | checkAuth() | enforceAuth() | . The following should stay in user.service.ts: . | disallowedUsernames and storedUsers (which should not be exported) | populateSafeUserInfo() | createUser() | getUsersByUsername() | updateUser() | resetStoredUsers() | . You can add additional exported functions from auth.service.ts if needed — you’ll need to create at least one other helper function to create and/or update AuthRecord records, and call those helper functions within user.service.ts. Moving these functions will break a lot of other parts of the server, but using TypeScript, the linter, and your tests, it should not be too arduous to find what broke and fix it. This task is worth 15 points: . | 6 points for the all the functions ending up in their correct files as described above | 5 points for tests passing and for user.service.ts and auth.service.ts still having 100% branch coverage (minus 1 point for each missing coverage-percentage, but no negative points, zero points if any tests fail or if TypeScript tests fail because of the refactor). Don’t worry about coverage in any other files. | 4 points for all functions having correct code style and documentation | . ",
    "url": "/CS4530-Spring-2026/assignments/ip1#4-implementation-tasks",
    
    "relUrl": "/assignments/ip1#4-implementation-tasks"
  },"22": {
    "doc": "Individual Project 1",
    "title": "5. Grading Summary",
    "content": "The assignment as a whole is worth 100 points. | Task 1: 25 points | Task 2: 20 points | Task 3: 20 points | Task 4: 20 points | Task 5: 15 points | . ",
    "url": "/CS4530-Spring-2026/assignments/ip1#5-grading-summary",
    
    "relUrl": "/assignments/ip1#5-grading-summary"
  },"23": {
    "doc": "Individual Project 1",
    "title": "Individual Project 1",
    "content": "The individual and group projects for this course place you in the role of the most recent hire at GameNite, an interactive application for people who like playing, or commenting on, multiplayer strategy games. It recently received a large investment thanks to its elevator pitch, “what if we had a version of Twitch, but for correspondence chess?” . GameNite is a web application that consists of some code that runs in each client’s web browser, and also code that runs on a server. By the end of the semester, you’ll propose, design, implement, and test new features for our project. We understand that some of you may have some web development experience, but don’t expect that most of you do, the goal of this first project is to get you up to speed with our existing codebase and development environment. The objectives of this assignment are to: . | Get you familiar with the basics of TypeScript, VSCode, and the project codebase | Get familiar with how REST API requests work | Learn how to read and write code in TypeScript | Learn how to write unit tests with Vitest | Translate high-level requirements into code | . ",
    "url": "/CS4530-Spring-2026/assignments/ip1",
    
    "relUrl": "/assignments/ip1"
  },"24": {
    "doc": "1 - Orientation & User Stories",
    "title": "1 - Orientation & User Stories",
    "content": "Learning Objectives: . After this lecture, you will be able to: . | Explain in general terms what software engineering is | List your weekly obligations as a student | List the requirements for completing the course | Explain the structure of a user story | Identify and fix user stories that don’t have the correct structure | Define the relationship between conditions of satisfaction and user stories, and the difference between essential, desired, and extension conditions of satisfaction | Identify functional and non-functional requirements, and give examples of each | . Important Dates: . | Individual Project 1 Due Wednesday, January 21 by 11am (EST) | . Lecture Slides: . | Course Introduction Slides PDF, PPT | User Stories Slides PDF, PPT | . Activity . | Working with User Stories | . Tutorials . | Installing a Development Environment | Getting Started with TypeScript | Guide to API Requests and Installing Postman | . Resources . | Class Syllabus and Policies | INVEST criteria for user stories | New to agile? INVEST in good user stories — introduction to both user stories and INVEST criteria | Domain modeling made functional - the first section in Chapter 2, “Interview with a Domain Expert,” has a worked example of soliciting a client’s needs for software. | Project Overview | . ",
    "url": "/CS4530-Spring-2026/modules/1-user-stories",
    
    "relUrl": "/modules/1-user-stories"
  },"25": {
    "doc": "2 - From Requirements to Tests",
    "title": "2 - From Requirements to Tests",
    "content": "Learning Objectives: . After this lecture, you will be able to: . | Explain the overall purposes of requirements analysis | Recall the three major dimensions of risk in requirements analysis | Explain the connection between requirements analysis and user stories | Explain the basics of Test-Driven Development | Explain the connection between conditions of satisfaction and testable behaviors | Begin developing simple applications using TypeScript and Vitest | . Important Dates: . | Individual Project 1 Due Wednesday, January 21 by 11am (EST) | . Lecture Slides: . | Requirements Analysis Slides PDF, PPT | Test-Driven Development Slides PDF, PPT | . Activity . | TDD Activity | . Tutorials . | Installing a Development Environment | Getting Started with TypeScript | Writing Tests with Vitest | . Resources . | Podcast: Kent Beck on Software Engineering Daily - An interview with Kent Beck (creator/evangelizer of TDD) about his time at Facebook and the relationship between Facebook and TDD. | INVEST criteria for user stories | Value Sensitive Design | Domain modeling made functional - the first section in Chapter 2, “Interview with a Domain Expert,” has a worked example of soliciting a client’s needs for software. | Project Overview | . ",
    "url": "/CS4530-Spring-2026/modules/2-requirements-to-tests",
    
    "relUrl": "/modules/2-requirements-to-tests"
  },"26": {
    "doc": "Modules",
    "title": "Modules",
    "content": " ",
    "url": "/CS4530-Spring-2026/modules/",
    
    "relUrl": "/modules/"
  },"27": {
    "doc": "Policies",
    "title": "Grading",
    "content": "There will be individual projects (previously known as assignments) and a team project (in a group of 4 members). The overall grading breakdown is: . | 30% Individual project (three individual project deliverables, equally weighted) | 40% Team project (including peer evaluations / surveys) | 10% Participation in synchronous class, activities, and project-related work sessions | 20% Exam | . We generally follow the grading scale that looks like this: As for 90s, Bs for 80s, Cs for 70s, Ds for 60s and F for &lt;60. Each instructor uses their own thresholds for ‘+’ and ‘-‘ grades. Assignment of team project grades: In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student (which might arise to 100% deduction for not contributing to the project at all). We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluation {during and/or} at the end of the project. We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Assignment of final grades: Although each instructor will use the same lesson plans and assignments, we expect that there may be variation in grades when compared between sections. Hence, each instructor will assign final grades to students in their sections, and reserve the right to apply different curves than are used by the other instructors. With each graded assignment, students will be provided with the distribution of all grades in their section. Grading grievances: If you have concerns regarding the grading of your work, please let us know right away by opening a regrade request. All regrade requests must be submitted within 7 days from your receipt of the graded work. If your regrade request is closed and you feel that the response was not satisfactory, you may appeal to the instructor via email within 48 hours. ",
    "url": "/CS4530-Spring-2026/policies/#grading",
    
    "relUrl": "/policies/#grading"
  },"28": {
    "doc": "Policies",
    "title": "Homework policy",
    "content": "Students must work individually on all homework assignments. We encourage you to have high-level discussions with other students in the class about the assignments, however, we require that when you turn in an assignment, it is only your work. That is, copying any part of another student’s assignment is strictly prohibited, and repercussions for doing so will be severe (up to and including failing the class outright). You are free to reuse small snippets of example code found on the Internet (e.g. via StackOverflow) provided that it is attributed. If you are concerned that by reusing and attributing that copied code it may appear that you didn’t complete the assignment yourself, then please raise a discussion with the instructor. Remember: The basic policy is that you are responsible for the code you submit. We reserve the right to interview you orally to make sure that you understand everything in your submission. Late Policy . Your work is late if it is not turned in by the deadline. For individual Projects and Activities: . | 10% will be deducted for late work turned in within 24 hours after the due date. | Work submitted more than 24 hours late will receive a zero. | . For group submissions (i.e., Final Project Deliverbles): . | No late submission is allowed. | . If you’re worried about being busy around the time of a HW submission, please plan ahead and get started early. Homework that does not compile or does not run will receive at most 50% credit. For fairness to all, there are no exceptions to the above rules. ",
    "url": "/CS4530-Spring-2026/policies/#homework-policy",
    
    "relUrl": "/policies/#homework-policy"
  },"29": {
    "doc": "Policies",
    "title": "Activities and Attendance Policy:",
    "content": "Most lectures will feature interactive activities (similar to labs) and/or polls that support the material being presented. You must be present in class to participate in the activity or take the poll (participating in an activity while not attending the synchronous session will be considered academic dishonesty and will be treated harshly). Attendance for any lecture or synchronous meeting that involves activities, ‘work on project’ sessions, project-related meetings, project demos/presentations is required. In addition, each instructor may have a different style for assigning participation grades, but historical grading information suggests that each style results in a similar overall grade distribution. Participation grades will be posted on Canvas, and will be updated regularly. Sometimes you cannot avoid missing a class. If you need to be away from class, it is your responsibility to inform the instructor {as soon as possible, preferably before class} to receive credit for any participation and catch up on the materials discussed in the class. University policy on attendance can be found here. Please note that we consider lecture days (the ones that include activities), ‘work on project’ sessions, and project meeting/demos/presentations days as lab days. Wellness days typically cannot be used for lab days. Please work with your instructors if you have to miss one. If you join class in person, you are strongly encouraged to bring your laptop or phone to class so that you can participate in the activities. ",
    "url": "/CS4530-Spring-2026/policies/#activities-and-attendance-policy",
    
    "relUrl": "/policies/#activities-and-attendance-policy"
  },"30": {
    "doc": "Policies",
    "title": "Academic Integrity",
    "content": "Students must work individually on all homework assignments. We encourage you to have high-level discussions with other students in the class about the assignments, however, we require that when you turn in an assignment, it is only your work. That is, copying any part of another student’s assignment is strictly prohibited. If you steal someone else’s work, you fail the class. You are responsible for protecting your work. If someone uses your work, with or without your permission, you fail the class. To ensure that students have completed the work themselves (and have gained necessary understanding), instructors might require students to explain the work they have submitted. We will consider adjusting grades based on your understanding of the course material. Be sure to review our policy on use of AI. If you are concerned that by reusing and attributing that copied code it may appear that you didn’t complete the assignment yourself, then please raise a discussion with the instructor. If you are in doubt whether using others’ work is allowed, you should assume that it is NOT allowed unless the instructors confirm otherwise. ",
    "url": "/CS4530-Spring-2026/policies/#academic-integrity",
    
    "relUrl": "/policies/#academic-integrity"
  },"31": {
    "doc": "Policies",
    "title": "Classroom Environment",
    "content": "To create and preserve a classroom atmosphere that optimizes teaching and learning, all participants share a responsibility in creating a civil and non-disruptive forum for the discussion of ideas. Students are expected to conduct themselves at all times in a manner that does not disrupt teaching or learning. Your comments to others should be constructive and free from harassing statements. You are encouraged to disagree with other students and the instructor, but such disagreements need to respectful and be based upon facts and documentation (rather than prejudices and personalities). The instructors reserve the right to interrupt conversations that deviate from these expectations. Repeated unprofessional or disrespectful conduct may result in a lower grade or more severe consequences. Part of the learning process in this course is respectful engagement of ideas with others. Please don’t be late. You are an essential part of the class. Your participation is an essential part of the class. If you are late, please be courteous to others when entering. BE PRESENT WHEN YOU ARE ATTENDING CLASS. Please do not distract yourself from the class by doing other activities such as phone calls, email, facebook, chat/IM/texting, games, web surfing – unless it has a direct bearing on the course. Then, by all means, surf away! . ",
    "url": "/CS4530-Spring-2026/policies/#classroom-environment",
    
    "relUrl": "/policies/#classroom-environment"
  },"32": {
    "doc": "Policies",
    "title": "Accommodations for Disabilities",
    "content": "Students who have disabilities who wish to receive academic services and/or accommodations should visit the Disability Access Services at 20 Dodge Hall or call (617) 373-2675 (previously known as DRC) Please be sure to provide your instructor with DAS’s accommodations letter early in the semester in order to avoid logistical challenges. This course includes a significant group work including project, and providing extensions for group work can be complex. DAS accomodations often do not apply to group submissions but we encourage you to work with your instructors to see how course staff can provide the support you might need. As-per the DAS’s policy, it is the student’s responsibility to coordinate with the instructor in order to request suitable accommodations. ",
    "url": "/CS4530-Spring-2026/policies/#accommodations-for-disabilities",
    
    "relUrl": "/policies/#accommodations-for-disabilities"
  },"33": {
    "doc": "Policies",
    "title": "Title IX Notice",
    "content": "Title IX of the Education Amendments of 1972 protects individuals from sex or gender-based discrimination, including discrimination based on gender-identity, in educational programs and activities that receive federal financial assistance. Northeastern’s Title IX Policy prohibits Prohibited Offenses, which are defined as sexual harassment, sexual assault, relationship or domestic violence, and stalking. The Title IX Policy applies to the entire community, including students, faculty and staff of all gender identities. Faculty members are considered “responsible employees” at Northeastern University, meaning they are required to report all allegations of sex or gender-based discrimination to the Title IX Coordinator. If you or someone you know has been a survivor of a Prohibited Offense, confidential support and guidance can be found through University Health and Counseling Services staff and the Center for Spiritual Dialogue and Service clergy members. By law, those employees are not required to report allegations of sex or gender-based discrimination to the University. Alleged violations can be reported non-confidentially to the Title IX Coordinator within The Office for Gender Equity and Compliance at: titleix@northeastern.edu and/or through NUPD (Emergency 617.373.3333; Non-Emergency 617.373.2121). Reporting Prohibited Offenses to NUPD does NOT commit the victim/affected party to future legal action. In case of an emergency, please call 911. Please visit www.northeastern.edu/ouec for a complete list of reporting options and resources both on- and off-campus. ",
    "url": "/CS4530-Spring-2026/policies/#title-ix-notice",
    
    "relUrl": "/policies/#title-ix-notice"
  },"34": {
    "doc": "Policies",
    "title": "Policies",
    "content": " ",
    "url": "/CS4530-Spring-2026/policies/",
    
    "relUrl": "/policies/"
  },"35": {
    "doc": "Project Overview",
    "title": "Project Overview",
    "content": "The individual and team project for this class are designed to mirror the experiences of a software engineer joining a new development team: you will be “onboarded” to our codebase, make several individual contributions, and then form a team to propose, develop and implement new features. The codebase that we’ll be developing on is a GameNight project. You will get an opportunity to work with the starter code which provides basic skeleton for the app and then additional features will be proposed and implemented by you! All implementation will take place in the TypeScript programming language, using React for the user interface. Overview of Project Deliverables . | Date | Deliverable | Description | . | 01/28/2026 | Team Formation Survey | Specify preferences for teammates | . | 02/02/2026 | Project Kick-off Meeting | Schedule a meeting with your Mentor TA during this week | . | 02/11/2026 | Preliminary Project Plan | Propose a new feature for GameNite project that can be planned and implemented within 7 weeks | . | 02/25/2026 | Revised Project Plan | Refine the scope of your feature based on staff feedback, define detailed requirements and project acceptance criteria. | . | 04/10/2026 | Project Delivery - Implementation and Documentation | Deliver/Deploy your new features, including design documentation and tests | . | 04/20/2026 | Individual Reflection | Reflect on the evolution of your project, process and team dynamics | . Summary of Project Grading . Your overall project grade (which will account for 40% of your final grade in this course) will be the weighted average of each of the deliverables. | Planning (20%) . | This includes the Preliminary Project Plan and the Revised Project Plan. | . | Process (20%) . | This includes: use of a structured development process, including regular git commits, pull requests, code reviews, timely completion of progress reports and individual/team surveys, and weekly meetings with TA Mentor. | This also includes appropriate division of labor within the project (i.e., roughly equal). For full credit, each member of the team must have at least 2 commits during the each sprint (even when using pair programming). | . | Product (40%) . | 20% Successful delivery of your Minimum Viable Product as defined in your project plan | 10% Desirable delivered features | 10% Test suite of your features. | . | Reports (20%) . | 10% Final Report | 10% Poster and Demo | . | Individual Reflection (required to receive an ‘A’) | . In cases where team members do not equally contribute to the project, we may assign different grades to different individuals, up to an extreme of deducting 50% of the team project grade for a student (which might arise to 100% deduction for not contributing to the project at all). We will evaluate each individual’s contribution on the basis of a variety of factors, including progress reports at weekly meetings, through inspecting version control history, through each students’ self-reflection, and through each students’ peer evaluations (during and/or at the end of the project). We will make regular efforts to collect and distribute this feedback throughout the project — our ultimate goal is for all students to participate and receive full marks. Team Formation . All projects will be completed in a team of 4 students. All students in each team MUST be in the same section of the class. The very first deliverable for the project will be a self assessment and team preference survey: you will be able to indicate your preferences for teammates. The instructors will assign students to the teams based on a number of factors including your responses to the survey and diversity of skills for the teammates. Team Meetings with TA Mentor . Each team will be assigned a TA to act as a mentor, who will work closely with you for the entire project and also will serve as your point of contact for project questions and grading. During Week 5, you will arrange a “Kickoff Meeting” with your TA mentor, where you will meet your TA mentor and have the opportunity to share any early ideas that you might want feedback on before submitting the your preliminary project plan. Once project begins in full force, you will have weekly meetings with your TA mentor (scheduled at your team’s and the TA’s convenience) in order to help ensure that you are making progress on the project, and to help address problems that you encounter (be they technical or non-technical problems). Weekly meetings will often include review of your pull requests, github commits, code reviews and demos from each group. Preliminary Project Plan . All projects will involve frontend and backend development of new features for GameNite. Once teams have been formed, you and your team will decide what kind of new features you would like to build. Your features should be something that can be implemented within the timeframe allotted (5-7 weeks), and will be implemented in a fork of the main codebase. Given that you will be up-to-speed on the project codebase (and have been introduced to TypeScript, React, NodeJS, and testing frameworks), and that you will have a team of three or four, we expect that the feature that you propose will be more complex than the feature implemented in the individual projects. The project plan will focus on two sections: . | User stories and conditions of satisfaction that describe the features that you plan to implement. Each Condition of Satisfaction is prioritized (Priorities are: Essential, Desirable, or Extension). The set of essential items will constitute the “Minimum Viable Product” discussed above. Teams are responsible for all essential and desirable work. | Work breakdown: Map your user stories to engineering tasks. Assign each task to a team member (or pair of team members), provide an estimate for how long each task will take, a brief rationale for that estimate, and schedule those stories into sprints. | . Creating a GitHub Repository . Your team’s development must take place within a GitHub repository in our GitHub Classroom. This repository will be private, and visible only to your team and the course staff. After the semester ends, you are welcome to make it public - you will have complete administrative control of the repository. We will provide instructions to set up these repositories for all groups and will also provide the starter code for the project (after the revised project plans are submitted). Revised Project Plan . Based on the feedback that you receive from the course staff, you will revise your preliminary project plan, creating a more detailed plan to implement your new feature. The project plan will include: . | Revised user stories and conditions of satisfaction (based on feedback on the preliminary project plan) | Revised work breakdown (based on feedback on the preliminary project plan) | . Your team will self-organize, as agile teams do, and will use the work breakdown and schedule as the basis for weekly check-ins with your team’s TA. Software Development Process . Each team is expected to use of a structured development process, including use of pull requests and code reviews for their regular github commits. You will also need to ensure appropriate division of labor within the project (i.e., roughly equal). Teams will also be expected to complete regular progress reports (or sprint retrospectives), and provide honest feedback as part of individual/team surveys. Peer evaluations will also be used (for Week 6, 8, 10-14). Please note that one of the most important factors in successfully completing a team project is having open, honest and effective communication between all team members as well as stakeholders. Project Implementation and Documentation . Your final team deliverable will be a “release” of your new feature on GitHub (with tests), and will be accompanied by a demo. Your final team deliverable will include: . | The implementation of your new features | Automated tests for your new features | deployment of your application | A Final Report | A Poster &amp; Demo (each instructor will provide specifics of the demo, which might vary for each section) | . Accompanying the final team deliverable will be an individual reflection, which every student must submit on their own, which will include your reflections on: . | The evolution of your project concept: How does the project that you delivered compare to what you originally planned to deliver? What caused these deviations? | The software engineering processes that you feel could have been improved in your project: were there any procesess that in hindsight, you wish that you followed, or wish that you followed better? | Your team dynamic: Provide a frank (and ideally, blameless) postmortem of your and your teammates collaborative performance and participation. If you had to do this same project over with the same teammates, what would you have done differently (or not) to improve your team’s overall performance? | . The details for the final project deliverable and associated rubrics will be released by Week 10. ",
    "url": "/CS4530-Spring-2026/assignments/project-overview",
    
    "relUrl": "/assignments/project-overview"
  },"36": {
    "doc": "Other Resources",
    "title": "Other Resources",
    "content": "There are many articles, blogs, books and podcasts that are very interesting for more reading on the topics discussed in class. We’ll update this list as the semester goes, and if you have suggestions of materials to share, please let us know and we’ll add it to the list. Podcasts . The Software Engineering Radio podcast (also available wherever you get your podcasts) aims to produce educational material for professional softare developers, and includes conversations between experts and researchers on various software engineering topics. Here are a few of our favorites that are most relevant to topics that we cover in this class: . | Donny Nadolny on Debugging Distributed Systems, with Robert Blumen, 2017 | Jafar Soltani on Continuous Delivery for Multiplayer Games, with Nate Black, 2018 | Chris Richardson on Microservice Patterns, with Robert Blumen, 2019 | Margaret Burnett on Gender, Cognitive Styles and Usability Bugs, with Felienne Hermans, 2019 | Michaela Greiler on Code Reviews, with Felienne Hermans, 2020 | Ipek Ozkaya on Managing Technical Debt, 2021 | . Code style . | Research paper: To camelcase or under_score, Dave Binkley et al | Research paper: I know what you did last summer: an investigation of how developers spend their time, Minelli, Mocci and Lanza | Research paper: A metric for software readability, Buse and Weimer | Book (free via library): “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | . Debugging . | Book (free via library): “Effective Debugging: 66 Specific Ways to Debug Software and Systems” by Diomidis SpinellisA helpful guidebook for debugging, laying out different strategies that are effective for testing different kinds of debugging hypotheses. | . Design Patterns . | Book (free via library): “Design Patterns Explained: A New Perspective on Object-Oriented Design” by Alan Shalloway and James TrottIn-depth coverage of design patterns, considering why they are important in software development, how to apply them, and descriptions of some common patterns. | Book (free via library): “Refactoring to Patterns” by Joshua KerievskyA unification of the classic Gang of Four Design Patterns work with Fowler’s refactoring work, with practical example of how to introduce patterns into existing code bases to improve code quality. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | . Infrastructure + Operations . | Book (free via library) “Site Reliability Engineering” By Betsy Beyer, Chris Jones, Niall Richard Murphy, Jennifer Petoff Site Reliability Engineering is a topic very related to software engineering: while software engineers might focus primarily on the design and development of software systems, SRE’s are engineers who focus on the deployment, monitoring and maintenance of that software. This book documents the SRE practices at Google. | . JavaScript . | Book (free via library): “Modern JavaScript for the Impatient” by Cay Horstmann | . Program Understanding . | Book: “The Programmer’s Brain” by Felienne Hermans A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | . ",
    "url": "/CS4530-Spring-2026/resources/",
    
    "relUrl": "/resources/"
  },"37": {
    "doc": "Section 1 - Calendar",
    "title": "Section 1 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s1",
    
    "relUrl": "/calendar/s1"
  },"38": {
    "doc": "Section 2 - Calendar",
    "title": "Section 2 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s2",
    
    "relUrl": "/calendar/s2"
  },"39": {
    "doc": "Section 3 - Calendar",
    "title": "Section 3 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s3",
    
    "relUrl": "/calendar/s3"
  },"40": {
    "doc": "Section 4 - Calendar",
    "title": "Section 4 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s4",
    
    "relUrl": "/calendar/s4"
  },"41": {
    "doc": "Section 5 - Calendar",
    "title": "Section 5 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s5",
    
    "relUrl": "/calendar/s5"
  },"42": {
    "doc": "Section 6 - Calendar",
    "title": "Section 6 - Calendar",
    "content": " ",
    "url": "/CS4530-Spring-2026/calendar/s6",
    
    "relUrl": "/calendar/s6"
  },"43": {
    "doc": "Calendar",
    "title": "Calendar",
    "content": "Given the synchronization amongst the sections, and the academic calendar starting on Monday, the course material generally is designed to run on weeks from Monday-Sunday. We provide a schedule for each section: . ",
    "url": "/CS4530-Spring-2026/calendar/",
    
    "relUrl": "/calendar/"
  },"44": {
    "doc": "Staff",
    "title": "Staff",
    "content": "For technical questions related to the codebase, please check piazza first (or post a query there). For discussing the course material or the individual projects, please feel free to attend whichever TA’s office hours are convenient. For project-related questions, please coordinate a time to chat directly with your assigned project mentor. ",
    "url": "/CS4530-Spring-2026/staff/",
    
    "relUrl": "/staff/"
  },"45": {
    "doc": "Staff",
    "title": "Office Hours",
    "content": "All TA office hours will be held virtually. We will explore the options of holding in-person office hours too, subject to interest from students/TAs and availability of a room. Instructor office hours may be held in-person or remotely. TA Office Hours are hosted on Microsoft Teams, using the Khoury Office Hours app. Please see the user guide for information on how to log in and ask questions. We usually do not hold office hours during school holidays (Spring Break, MLK Day, President’s Day, Indigenous Peoples’ Day, Veteran’s Day and Thanksgiving Break) . ",
    "url": "/CS4530-Spring-2026/staff/#office-hours",
    
    "relUrl": "/staff/#office-hours"
  },"46": {
    "doc": "Staff",
    "title": "Schedule",
    "content": " ",
    "url": "/CS4530-Spring-2026/staff/#schedule",
    
    "relUrl": "/staff/#schedule"
  },"47": {
    "doc": "Staff",
    "title": "Instructors",
    "content": "Adeel Bhutta . a.bhutta@northeastern.edu . Section: CS4530 Sections 1, 2 &amp; 3 . Office Hours: . | In-Person: Thursdays 140pm-230pm, Meserve 337 (No Appointment Needed) | or Book an appointment with me for a Virtual meeting via Zoom. | . Rob Simmons . r.simmons@northeastern.edu . Section: CS4530 Sections 5 &amp; 6 . Office Hours: . | Book an appointment with me for a Virtual meeting via Google Meet | . Mitch Wand . wand@ccs.neu.edu . Section: CS4530 Section 4 . Office Hours: . | on Zoom, directly following class | . ",
    "url": "/CS4530-Spring-2026/staff/#instructors",
    
    "relUrl": "/staff/#instructors"
  },"48": {
    "doc": "Staff",
    "title": "Teaching Assistants",
    "content": "Anirudh Revalli . revalli.a@northeastern.edu . Ansh Sumeet Sarin . sarin.ans@northeastern.edu . Apurva Saini . saini.ap@northeastern.edu . Ciaran Flanagan . flanagan.ci@northeastern.edu . Darshil Vipul Shah . shah.darshilv@northeastern.edu . Divit Pratap Singh . singh.divi@northeastern.edu . Furqan Abid . abid.fu@northeastern.edu . Peter Li . li.pet@northeastern.edu . Rimsha Kayastha . kayastha.r@northeastern.edu . Rishika Reddy Vootkur . vootkur.r@northeastern.edu . Saran Jagadeesan Uma . jagadeesanuma.s@northeastern.edu . Satyam Priyam . priyam.s@northeastern.edu . Shashank More . more.shas@northeastern.edu . Tanya Shukla . shukla.tan@northeastern.edu . Vaishali Singh . singh.vais@northeastern.edu . Ved Dipak Deore . deore.v@northeastern.edu . Vikas Neriyanuru . neriyanuru.v@northeastern.edu . Yash Mahesh Burshe . burshe.y@northeastern.edu . ",
    "url": "/CS4530-Spring-2026/staff/#teaching-assistants",
    
    "relUrl": "/staff/#teaching-assistants"
  },"49": {
    "doc": "Code Style",
    "title": "Code Style",
    "content": "Programs are easier to read and to understand when they are written in a familiar style and follow standard coding conventions. Most organizations that develop software therefore require programmers to write programs that follow the organization’s preferred style and coding conventions. These conventions can be very elaborate. Many of the guidelines are, in fact, arbitrary. When you are working on a coding project with other developers, different developers often have preference for slightly different syntax, for instance: should our string literals be enclosed by single quotes (') or double quotes (\")? Should files be indented with spaces or tabs? In TypeScript, there are often multiple ways to accomplish the same goal, for instance, you could create a new empty array with the expression const myArray = new Array(), or const myArray = []. Sometimes there is no difference between these variants except for how it reads, and other times there may be unintended consequences of making the seemingly correct but subtly wrong choice. Thankfully, it is possible to write automated checkers (and, at times, fixers) for these style violations. All code that you write for this class will be checked by ESLint, and must be free of style warnings and errors. Our ESlint rules are derived from Airbnb’s JavaScript Style Guide, ESLint’s Recommended Rules, TypeScript/ESLint Recommended Rules, React ESLint Rules and React Hooks ESLint Rules. We do not suggest studying these lists directly, instead, begin writing code naturally, and allow your IDE’s built-in style checker to report issues as you find them. The most important rules to get started are: . | Indent using spaces, not tabs; use 2 spaces for each level of indentation | Enclose all string literals with single quotes, not double | Variables must be named using lowerCamelCase, types are named using UpperCamelCase. Constants (read-only variables that are assigned a static value once and not reused) must be named using UPPER_CASE_WITH_UNDERSCORES. | The maximum line length is 100 characters | . Naming . While the linter can automatically flag names that violate camelCase rules, it can not automatically determine that a name is “good” - this is a subjective judgement call. Please consider the following when choosing names: . | Names should be informative (e.g lineTooLong() rather than checkLineLength()) | Names for types are typically nouns or noun phrases. Interface names, however, might be adjectives (e.g. Serializable). Class names may be noun phrases that include the interface name (e.g. CuckooClock and DigitalClock for classes that implement the interface Clock). | Use noun-like names for functions or methods that return values (e.g. circleDiameter rather than calculateDiameter). (Exception: simple getters can still have names that begin with get). | Reserve verb-like names for functions that perform actions (e.g. addItem). | Use adjective phrases for predicates when possible (e.g. line.tooLong()) | Variable and property names should be descriptive of what the variable is for, and not be named after the type of the variable (which is captured in the variable’s type declaration) | Names for properties that are private must start with a _ | . Documentation and Comments . All public properties and methods (other than getters, setters, and constructors) must be documented using JSDoc-style comments that describes what the property/method does. Example: . /** The unique identifier for this player * */ private readonly _id: string; . /** * A handler to process a remote player's subscription to updates for a room * * @param socket the Socket object that we will use to communicate with the player */ . Consider adding comments within your code to describe non-obvious behavior, or to capture why the code is written the way that it is. Do not add comments that simply restate what can already be immediately discerned by reading the code. For example, here is a useful comment: . // No valid session exists for this token, hence this client's connection should be terminated socket.disconnect(true); return; . Here is a useless comment on the same code snippet: . // Disconnect the socket socket.disconnect(true); return; . Comments are for documentation, not for keeping track of old code you are no longer using (do not submit commented-out code). ",
    "url": "/CS4530-Spring-2026/policies/style/",
    
    "relUrl": "/policies/style/"
  },"50": {
    "doc": "Textbooks",
    "title": "Textbooks",
    "content": "This class is a survey of many sub-areas of software engineering, and an unfortunate result of this is that there is no single textbook that is appropriate for this class. However, there are several texts that have chapters that are quite relevant, and most of these books are available for free for Northeastern students through O’Reilly’s Safari Books online. To create your account, first visit this page: https://www.safaribooksonline.com/library/view/temporary-access/ and then select “Not Listed? Click Here” for institution, then enter your @northeastern.edu email address. After this first account creation, you’ll be able to log in directly to Safari Books Online with your @northeastern.edu email and no need for 2FA (hooray!). The schedule will list which chapters of which texts are relevant for each lecture: . | “Software Engineering at Google” By Titus Winters, Tom Manshreck and Hyrum Wright This book is effectively a manual that describes the software engineering practices at Google, and the rationale behind those practices | “Effective Software Testing: A Developer’s Guide” by Mauricio Aniche (Not on Safari) A focused discussion of software testing concepts, with concrete examples using popular Java testing frameworks. | “The Programmer’s Brain” by Felienne Hermans (Not on Safari) A survey of research on programming and cognition, covering topics such as how to read code more effectively and how to write code that is easier to read and share. | “Fundamentals of Software Architecture” By Mark Richards and Neal Ford An overview of software architectural patterns and their role in successful software projects. | “Refactoring: Improving the Design of Existing Code” By Martin Fowler The definitive list of “code smells” that should be avoiding in programming, matched up with “refactoring” techniques to improve that code | “Learn React with TypeScript 3” by Carl RipponA solid reference for React, describing how to get started, plus more advanced features like React’s Router and testing using Jest | “Programming TypeScript” by Boris ChernyA useful introduction to TypeScript, written assuming familiarity with programming in languages like Java, C# or python. | . ",
    "url": "/CS4530-Spring-2026/textbooks/",
    
    "relUrl": "/textbooks/"
  },"51": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/CS4530-Spring-2026/tutorials/",
    
    "relUrl": "/tutorials/"
  },"52": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Tutorial: Guide to API Requests and Installing Postman",
    "content": " ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#tutorial-guide-to-api-requests-and-installing-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman#tutorial-guide-to-api-requests-and-installing-postman"
  },"53": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Contents",
    "content": ". | Introduction to API Requests and Postman | Breakdown of an API Request | Authentication in APIs | Testing API Endpoints | Steps to Install Postman | Using Postman: Basic Steps | Setting Up Authentication in Postman | Setting up environment Variables in Postman | Saving API Requests and Using History | Organizing Requests into Collections | Recommended Tools | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#contents",
    
    "relUrl": "/tutorials/week1-apirequests-postman#contents"
  },"54": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Introduction to API Requests and Postman",
    "content": "APIs (Application Programming Interfaces) are essential tools that allow different software applications to communicate with each other. As developers, it’s crucial to understand how to interact with APIs, which involves making API requests. API requests are structured interactions where one software sends a request to retrieve or send data to another. Postman is a popular API testing tool that allows developers to build, test, and modify APIs quickly and easily. It provides an interface to interact with APIs and simplifies API development. Postman supports making requests like GET, POST, PUT, DELETE, and more. With this guide, you can: . | Understand the basics of making GET and POST requests to an API. | Learn how to use Postman to send requests and test APIs. | Test API responses to ensure that they return the expected results. | . Types of API Requests: . There’s a whole vocabulary of HTTP requests, but GET and POST are the two most important: . | GET: Retrieves data from an API. It’s commonly used when you want to fetch information without making any changes. | Example: Use a GET request to retrieve a list of videos related to the one you’re currently watching on a streaming platform (e.g., GET /videos/related). | . | POST: Submits new data to an API to create a resource. It’s used when you need to send data to the server to create something new. | Example: Use a POST request to save a newly uploaded video on a platform (e.g., POST /videos). | . | . Each of these request types serves a specific purpose in API interactions, and Postman allows you to easily switch between them to test and build your APIs. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#introduction-to-api-requests-and-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman#introduction-to-api-requests-and-postman"
  },"55": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Breakdown of an API Request",
    "content": "Each API request has key components: . 1. URL . For this URL -&gt; https://localhost:8000/api/users . The URL defines the location of the API you’re interacting with: . | Protocol (https://) | Domain (localhost) | Port (8000) | Endpoint (/api/users) | . 2. Method . Defines the action type: . | GET: Retrieves data | POST: Submits new data | PUT: Updates data | DELETE: Deletes data | . 3. Parameters (GET) vs. Body (POST) . | GET sends data as query parameters in the URL: https://api.example.com/users?age=25 In this example, age=25 is a query parameter used to filter 25 year old users from the list of users. | POST sends data in the body (usually JSON). In this example, username and password entered by the user is getting sent to the server for log in. | . { \"username\": \"user\", \"password\": \"password\" } . 4. Headers . Headers provide additional information about the request or the client making it. They help the server understand the request. Some common headers include: . | Content-Type: Specifies the format of the request body (e.g., application/json for JSON data). | Authorization: Contains credentials like API keys or tokens required to access certain endpoints. | Example: Authorization: Bearer &lt;your-api-token&gt; . | . | Accept: Specifies the format in which the client expects the server to return the response (e.g., application/json). | Example: Accept: application/json . | . | . 5. Response . After the server processes the request, it sends back a response. The response typically includes: . | Status Code: A number indicating the result of the request. | Common status codes: . | 200 OK: The request was successful. | 201 Created: The resource was successfully created (used for POST requests). | 400 Bad Request: There was an error in the request. | 404 Not Found: The resource could not be found. | 500 Internal Server Error: An error occurred on the server. | . | . | Response Body: Contains the data returned by the API, usually in JSON format. For example, when creating a new user, the server might return the new user data as response like this: . { \"id\": 1, \"username\": \"newuser\", \"email\": \"newuser@example.com\" } . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#breakdown-of-an-api-request",
    
    "relUrl": "/tutorials/week1-apirequests-postman#breakdown-of-an-api-request"
  },"56": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Authentication in APIs",
    "content": "Common Authentication Methods . | API Key Authentication | . Headers: X-API-Key: your-api-key-here . | Bearer Token (JWT) | . Headers: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... | Basic Authentication | . Headers: Authorization: Basic base64(username:password) . | OAuth 2.0 More complex flow involving authorization servers and access tokens. | . Additional things to note: . | See this Mozilla documentation for further information on status codes. | It is good practice to use environment variables to store sensitive data or data repeatedly used, such as domain names, tokens, or credentials. | Request/Response validation helps ensure every API request and response are following the expected format with expected values. | See this Postman documentation for implementing comprehensive error handling on server-side. | You can also use cURL commands to transfer data with URLs through command line. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#authentication-in-apis",
    
    "relUrl": "/tutorials/week1-apirequests-postman#authentication-in-apis"
  },"57": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Testing API Endpoints",
    "content": "Testing endpoints allows you to verify that your backend behaves as expected before connecting it to a frontend. There are multiple ways to test API endpoints. Testing GET Requests in the Browser . Web browsers automatically send GET requests, making them useful for quick checks. Example: . http://localhost:8000/api/users . If the endpoint works, you should see a JSON response in the browser. This method is best for: . | Simple GET endpoints | Quick sanity checks | . Testing GET and POST Requests Using Postman . For more control over requests (especially POST requests), we use Postman. Postman allows you to: . | Choose the HTTP method | Set headers | Send JSON request bodies | View formatted responses and status codes | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#testing-api-endpoints",
    
    "relUrl": "/tutorials/week1-apirequests-postman#testing-api-endpoints"
  },"58": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Steps to Install Postman",
    "content": "Step 1: Download Postman . | Open your web browser and navigate to the official Postman website: https://www.postman.com/downloads/. | Select the latest version that is compatible with your operating system (Windows/macOS) and download. If you’re using a Mac or Linux, be sure to download the version that corresponds to your OS: Mac (Intel Chip, Apple Chip) or Linux (x64, arm64). | . Step 2: Install Postman . For Windows: . | Once the download is complete, find the setup file in your downloads folder (typically named Postman-win64-setup.exe). | Select and run the .exe file to install Postman. | . For macOS: . | Open the downloaded .dmg file. If your browser downloads the file as a ZIP file, find the file in the Downloads folder, unzip it, and open the Postman file. | Drag the Postman app icon into the “Applications” folder. | Once copied, go to your Applications folder and double-click the Postman icon to launch the app. You can also install Postman using the Homebrew package manager: | . brew install --cask postman . Linux: . | Unpack the downloaded Postman file using the following command: | . tar zxf linux_64 . Alternatively, you can install Postman on Linux from the Snap store page or by using the following command: . snap install postman . Step 3: Create an Account (Optional but Recommended) . Once Postman is installed: . | Open the Postman application. | You will be prompted to sign in or create a Postman account. You will be led back to the Postman window after signing in. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#steps-to-install-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman#steps-to-install-postman"
  },"59": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Using Postman: Basic Steps",
    "content": "Step 0: Ensure your backend is running and have a valid API endpoint to test . Step 1: Launch Postman . After installation, launch Postman. You’ll see a workspace where you can start creating requests. Step 2: Make Your First API Request . | Click on the “New” button at the top-left and select HTTP. | . | In the request window, choose the type of request method (GET, POST, PUT, DELETE) from the dropdown menu (default is GET). To send a GET request, enter the URL of the API you want to test in the input field (e.g., http://localhost:8000/question/getQuestionById/67062b6dd9d59b115c559096?username=user). Ensure that the params you are passing are correct. | . To send a POST request you need to enter the URL (e.g., http://localhost:8000/question/addQuestion) and include the Body as well. | Go to the Body tab. | Select raw. | Choose JSON as the format. | Enter the JSON data in this format: | . { \"title\": \"How do I use Postman?\", \"text\": \"I am trying to build an API using TypeScript, but I'm unable to test using Postman. How do I do this?\", \"tags\": [ { \"name\": \"Postman\", \"description\": \"API testing tool that allows developers to send HTTP requests.\" } ], \"asked_by\": \"Pavan Kumar\", \"ask_date_time\": \"2024-10-08T12:00:00.000Z\", \"answers\": [], \"views\": 0, \"up_votes\": [], \"down_votes\": [] } . | Click the Send button and wait for the response. | . Step 3: View the Response . | After clicking “Send,” Postman will display the API response below the request window. | You will see the Status Code, Response Body, Headers, and Cookies (if applicable). | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#using-postman-basic-steps",
    
    "relUrl": "/tutorials/week1-apirequests-postman#using-postman-basic-steps"
  },"60": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Setting Up Authentication in Postman",
    "content": ". | Go to the Authorization tab in your request | Select authentication type from dropdown | Enter credentials | Postman automatically adds appropriate headers | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#setting-up-authentication-in-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman#setting-up-authentication-in-postman"
  },"61": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Setting up environment Variables in Postman",
    "content": ". | Click the gear icon (⚙️) in top right | Select “Manage Environments” | Click “Add” to create new environment | Add variables. For example, | . Variable: base_url Initial Value: http://localhost:8000 Current Value: http://localhost:8000 Variable: api_token Initial Value: your-dev-token Current Value: your-dev-token . Using environment variables: . | In your requests, use double curly braces: | . URL: /api/users Headers: Authorization: Bearer . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#setting-up-environment-variables-in-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman#setting-up-environment-variables-in-postman"
  },"62": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Saving API Requests and Using History",
    "content": "One of Postman’s key features is the ability to save API requests for future use. This can save you time when testing or working on multiple endpoints. Additionally, Postman keeps track of your request history, allowing you to quickly revisit previous requests without re-entering all the details. To learn more about using Postman’s history, visit: Postman History. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#saving-api-requests-and-using-history",
    
    "relUrl": "/tutorials/week1-apirequests-postman#saving-api-requests-and-using-history"
  },"63": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Organizing Requests into Collections",
    "content": "Postman also allows you to save and organize requests into collections. A collection is essentially a folder where you can store multiple requests, making it easier to manage large projects and share API workflows with your team. For more information on creating and using collections, refer to the Postman documentation: Postman Collections. These features enhance your ability to efficiently manage, organize, and track your API development process within Postman. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#organizing-requests-into-collections",
    
    "relUrl": "/tutorials/week1-apirequests-postman#organizing-requests-into-collections"
  },"64": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Recommended Tools",
    "content": "In addition to using the Postman desktop app, you can also integrate Postman with Visual Studio Code through the Postman extension. This extension allows you to send API requests directly from your code editor. You can find the extension and its documentation here: Postman VS Code Extension. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman#recommended-tools",
    
    "relUrl": "/tutorials/week1-apirequests-postman#recommended-tools"
  },"65": {
    "doc": "Guide to API Requests and Installing Postman",
    "title": "Guide to API Requests and Installing Postman",
    "content": " ",
    "url": "/CS4530-Spring-2026/tutorials/week1-apirequests-postman",
    
    "relUrl": "/tutorials/week1-apirequests-postman"
  },"66": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS",
    "content": "Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. For this class, you will need Node.js version 24 (v24.12.0 was the latest version at time of writing, although any 24.x or 25.x version should work in theory). There are many ways that you can install Node.js: for instance, you can use a package manager like snap or homebrew to install it; you can download an installer directly from the Node.js website, and you can, of course, build it from source. Due to the complexity of running different Node.js versions on the same machine, we very strongly suggest using nvm, the node version manager. When language runtimes are in active development (like Node.js is), sometimes you end up needing to have multiple versions of Node.js installed, and different projects that you work on might require different versions of Node.js. These annoyances are quite rare, but when it happens that you need to have mutliple versions of Node.js installed, it’s super handy to have your system set up already so that installing multiple versions and switching between it is easy. You can use our instructions to set up nvm even if you have previously installed Node.js. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installing-nodejs",
    
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs"
  },"67": {
    "doc": "Installing a Development Environment",
    "title": "Installing NodeJS with NVM for Windows",
    "content": "Before starting the installation, make sure to kill your Visual Studio Code if you have it installed. To do that on Windows, open a command prompt(type cmd in the windows start bar, then select “Run as administrator”) and run the command taskkill.exe /IM code.exe. | Download nvm-setup.exe from the most recent release of nvm-windows (at time of writing this document, version was 1.2.2). | . | Run the executable nvm-setup.exe. | This should open the nvm installation wizard. | . | Accept the license agreement and click next. Continue to accept the default choices for any remaining prompts, and click “install”. If you receive messages along the lines of “NodeJS version XYZ is already installed, would you like nvm to control this installation,” select “Yes”. | Upon completion, you will see the below window . | . | Open a command prompt with administrative privileges (type cmd in the windows start bar, then select “Run as administrator”). | Verify the installation, run the command nvm version . | This should display the version of nvm installed. | | . | Install Node.js version 24 using the command nvm install 24. | To use this version of NodeJS, run the command nvm use 24. | The output will look like: . Now using node v24.12.0 (npm v11.6.2) . | . | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows",
    
    "relUrl": "/tutorials/week1-getting-started#installing-nodejs-with-nvm-for-windows"
  },"68": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Linux / Mac)",
    "content": "This tutorial assumes you’re using the Bash or Zsh shells (if you don’t know what that means, you’re probably using one of those). | Run either curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash or If wget is installed then run wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash. | For more details, refer to the NVM GitHub. | . | Close and reopen the active terminal. Note: You can also restart your terminal by running source ~/.bashrc or source ~/.zshrc depending on your shell. | Verify nvm is working by entering command -v nvm. If your terminal prints out nvm, it should be working. If you see nvm: command not found or no feedback, open a new terminal and trying again or restart from step 1. | Install the required version of Node.js by typing nvm install 24. | To use this version of NodeJS, run the command nvm use 24. Note: If this is your first time installing Node on your system, nvm will default to using version 24.x.x on every new terminal. You can run nvm ls to see the list of installed Node versions on your system. | The output will look like: . Now using node v24.12.0 (npm v11.6.2) . | . | . Installing NVM when using the fish terminal (Linux / Mac) . Note: When using the Fish terminal, nvm.fish should be used to install nvm. This is not a fish wrapper for nvm rather it is written from scratch using fish. Current version of NVM is not supported on terminals that are running fish or have installed fish in the past. | Install nvm.fish using Fisher: fisher install jorgebucaran/nvm.fish | Restart fish by entering fish in your active terminal | Verify nvm is working by entering nvm -v | Install the required version of Node.js by typing nvm install 24. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installation-steps-linux--mac",
    
    "relUrl": "/tutorials/week1-getting-started#installation-steps-linux--mac"
  },"69": {
    "doc": "Installing a Development Environment",
    "title": "Verification",
    "content": ". | Open a shell (for Linux / Mac) or windows powershell/command prompt (for Windows). | Run the command node -v | . | This should print the current version of nodeJS installed (24.x.x). | . | Run the command npm -v | . | This should print the current version of npm installed (v11.x.x). | | . | If you find that some other version is being used, run the command nvm use 24. For Linux / Mac, you can change the default to 24 by running the command nvm alias default 24. | . Note: The alias command is not compatible with nvm.fish. Instead, you can add a default version with the command exec nvm use 24 in your ~/.config/fish/config.fish file. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#verification",
    
    "relUrl": "/tutorials/week1-getting-started#verification"
  },"70": {
    "doc": "Installing a Development Environment",
    "title": "Installing Visual Studio Code (VSCode)",
    "content": "Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). VSCode also supports importing hotkey configurations from most other text editors and IDEs. Read more here. While you are required to use an IDE for this class, it is not mandatory to use VSCode: if you already are comfortable developing TypeScript or JavaScript in another suitable IDE (like IntelliJ), then you are welcome to continue to use that. However, VSCode is the “supported” option: if you struggle to get things like the linter set up correctly in VSCode, we will be happy to help you. However, we can’t provide such support for all IDEs. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installing-visual-studio-code-vscode",
    
    "relUrl": "/tutorials/week1-getting-started#installing-visual-studio-code-vscode"
  },"71": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | Administrative access on the host machine for software installation. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#pre-requisites",
    
    "relUrl": "/tutorials/week1-getting-started#pre-requisites"
  },"72": {
    "doc": "Installing a Development Environment",
    "title": "Installation Steps (Windows)",
    "content": ". | Download the VSCode installer from the VSCode website. | . | Run the installer to start the installation wizard for VSCode . | . | Accept the license agreement and click next. | . | Choose the installation directory of your choice and click next. | . | Click next on the select start menu folder screen. | . | Tick all check boxes on the select additional tasks menu and click next. | . | Review the settings on the the “Ready to install” screen and click Install to begin installation. | Once the installation is complete, you will see the below screen and you are ready to use VSCode. | . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installation-steps-windows",
    
    "relUrl": "/tutorials/week1-getting-started#installation-steps-windows"
  },"73": {
    "doc": "Installing a Development Environment",
    "title": "Installation (Mac)",
    "content": ". | Download the VSCode installer from the VSCode website. | Open the downloaded .zip file named along the lines of VSCode-darwin/-arm64/-universal. | Drag the extracted Visual Studio Code app to the Applications folder (found at /Applications). Do not skip this step! | Open VSCode from Launchpad or Spotlight Search. | . Alternatively, you can also install Visual Studio Code using homebrew using brew install --cask visual-studio-code which will install it as a normal application in your Mac. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installation-mac",
    
    "relUrl": "/tutorials/week1-getting-started#installation-mac"
  },"74": {
    "doc": "Installing a Development Environment",
    "title": "Installation (Linux)",
    "content": ". | The above instructions for Windows/Mac should also work, but VSCode is also provided as a snap package | . | Install snap if you haven’t already by running sudo apt update and then sudo apt install snapd. | Install VSCode by running sudo snap install --classic code. | Open VSCode as an application on your desktop. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#installation-linux",
    
    "relUrl": "/tutorials/week1-getting-started#installation-linux"
  },"75": {
    "doc": "Installing a Development Environment",
    "title": "Additional Extensions",
    "content": "VSCode comes with a rich set of extensions to aid in software development. Below is a list of extensions we strongly recommend. | Prettier - code formatter | ESLint - linter for JavaScript/TypeScript | Vitest - run, debug, and watch Vitest tests directly in VS Code (see the Unit Testing tutorial for detailed setup instructions) | . To install an extension: . | Click on the extensions tab on the left in VSCode (it looks like a pile of boxes, as shown here) . | . | Search for the extension (e.g. “ESLint”) | Click on Install. | Done! . | . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#additional-extensions",
    
    "relUrl": "/tutorials/week1-getting-started#additional-extensions"
  },"76": {
    "doc": "Installing a Development Environment",
    "title": "Additional Settings (Optional)",
    "content": "If you click through enough “Settings” menus, like this on a Mac (File &gt; Preferences &gt; Settings on Windows): . You should see a screen like this: . The following settings are recommended: . | “Files: Auto Save” — set to “afterDelay” | “Editor: Format On Save” - enable | “Prettier: Document Selectors” - add _.ts and _.tsx | “Editor: Bracket Pair Colorization” — enable | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#additional-settings-optional",
    
    "relUrl": "/tutorials/week1-getting-started#additional-settings-optional"
  },"77": {
    "doc": "Installing a Development Environment",
    "title": "Getting Started With Typescript",
    "content": "Typescript is a superscript of JavaScript which adds type information and other features. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#getting-started-with-typescript",
    
    "relUrl": "/tutorials/week1-getting-started#getting-started-with-typescript"
  },"78": {
    "doc": "Installing a Development Environment",
    "title": "Pre-requisites",
    "content": ". | NodeJS | VSCode (recommended but not required) | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#pre-requisites-1",
    
    "relUrl": "/tutorials/week1-getting-started#pre-requisites-1"
  },"79": {
    "doc": "Installing a Development Environment",
    "title": "Hello World",
    "content": ". | Create a new directory and open it with VSCode. | Create a new file called hello-world.ts. | You can do this from within VSC by typing ctrl + N, but this is not necessary. | . | Add the following code to the file: . let message = \"Hello, World!\"; console.log(message); message = \"Goodbye, World!\"; console.log(message); . | Open the terminal with ctrl + ~ or ctrl + ‘`’ (ctrl-backtick) . | Ensure that you are in the same directory as hello-world.ts. | . | Run the command node hello-world.ts. | This will give the result below. | | . | Modify your file to produce a type error by trying to write a number to the variable message that has type string: . | observe the message that you get. | | . | Run the command node hello-world.ts. What happens? | . Troubleshooting with VSCode: Did you follow these instructions successfully, but find a “Command not found” error when you try to run npm in VSCode? Try this: Close VSCode completely. Re-open it. In your command shell in VSCode, try again. We have noticed that if you have VSCode open while installing nvm, it is possible that VSCode will not see the new software installation until it’s closed and re-opened. You can also confirm that VSCode correctly sees the NodeJS installation by running echo %PATH% in your windows command shell in VSCode: it should include an entry similar to C:\\Program Files\\nodejs. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started#hello-world",
    
    "relUrl": "/tutorials/week1-getting-started#hello-world"
  },"80": {
    "doc": "Installing a Development Environment",
    "title": "Installing a Development Environment",
    "content": "This tutorial describes the basic steps needed to set up a development environment with NodeJS, TypeScript, and VisualStudio Code. At the end of this tutorial, you should have a complete local development environment that you can use to build and test code for this class. Contents: . | Installing NodeJS | Installing Visual Studio Code | Hello, World in TypeScript | . If you run into any difficulties following any of these steps, please post (in a non-private question) on Piazza. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-getting-started",
    
    "relUrl": "/tutorials/week1-getting-started"
  },"81": {
    "doc": "TypeScript Basics",
    "title": "TypeScript Basics",
    "content": "This tutorial describes the basic concepts and syntax of TypeScript with code examples. TypeScript is treated here as an extension of JavaScript, but it requires no prior knowledge to follow along. You can run the examples on Online TypeScript Editor . Contents: . | Types in TypeScript . | Boolean | Number | BigInt | String | Arrays | Tuples | Enums | Any | Unknown | Literal | . | Variable declaration in TypeScript | Objects | Control Flow Statements . | Equality vs Strict Equality | . | Loops | Array Functions . | ForEach | Map | Filter | Reduce | . | Functions . | Typing the function | Invoking the function | Optional and Default Parameters | Rest Parameters | Arrow Functions | Function Overloads | . | Classes . | Creating a class | Creating an abstract class | . | Type Aliases | Interfaces | Custom types | Generics | Modules | Object oriented programming concepts using TypeScript . | Inheritance | Polymorphism | Abstraction | Encapsulation | . | General Guidelines | tsconfig | . TypeScript is a superset of JavaScript. Thus, all JavaScript code is valid TypeScript code. TypeScript introduces a new concept, optional typing, to JavaScript. Let us begin by extending JavaScript to use the features of TypeScript and primitive types. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics",
    
    "relUrl": "/tutorials/week1-typescript-basics"
  },"82": {
    "doc": "TypeScript Basics",
    "title": "Types in TypeScript",
    "content": "Boolean . The boolean type has two values: true and false. Example: . let a = true // boolean var b = false // boolean const c = true // true let d: boolean = true // boolean let e: true = true // true . | Usage: You can compare them (with ==, ===, ||, &amp;&amp;, and ?), negate them (with !). | . Number . Number is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN. Example: . var b = Infinity * 0.10 // number const c = 5678 // 5678 let d = a &lt; b // boolean let e: number = 100 // number let f: 26.218 = 26.218 // number . | Usage: Numbers can do things, like addition (+), subtraction (-), modulo (%), and comparison (&lt;). When working with long numbers, use numeric separators to make those numbers easier to read. | . BigInt . The bigint type is the set of all BigInts, and supports things like addition (+), subtraction (-), multiplication (*), division (/), and comparison (&lt;). Example: . let a = 1234n // bigint const b = 5678n // 5678n var c = a + b // bigint let d = a &lt; 1235 // boolean let e = 88.5n // Error TS1353: A bigint literal must be an integer. let f: bigint = 100n // bigint let g: 100n = 100n . | Usage: It lets you work with large integers without running into rounding errors. While the number type can only represent whole numbers, BigInt can hold numbers larger than 253 – 1. | . String . String is the set of all strings and the things you can do with them like concatenate (+), slice (.slice),etc. Example: . let a: string = 'hello' // string let b: string = 'world' // string let c: string = a + ' ' + b // string . | Usage: Any functionality that requires the functionality of a string of characters. | . Here are a couple of string operations: . charAt() : This method returns the character from the specified index. Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string, called stringName, is stringName.length – 1. Syntax: . string.charAt(index) . slice() : This method extracts a section of a string and returns a new string. Syntax: . string.slice( beginSlice [, endSlice]) . split() : This method splits a String object into an array of strings by separating the string into substrings. Syntax: . string.split([separator][, limit]) . concat(): This method adds two or more strings and returns a new single string. Syntax: . string.concat(string2, string3[, ..., stringN]) . indexOf(): This method returns the index within the calling String object of the first occurrence of the specified value, starting the search at index or -1 if the value is not found. Syntax: . string.indexOf(searchValue[, fromIndex]) . Arrays . Like in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing. Arrays are iterable Objects with the keys as numbers. Example: . let a = [1, 2, 3] // number[] var b = ['a', 'b'] // string[] let c: string[] = ['a'] // string[] let d = [1, 'a'] // (string | number)[] const e = [2, 'b'] // (string | number)[] let f = ['red'] f.push('blue') // Avoid declaring arrays without types let g = [] // any[] - not recommended g.push(1) // number[] g.push('red') // (string | number)[] // Best practice: explicitly type empty arrays let h: number[] = [] // number[] - recommended approach h.push(1) // number[] . Tuples . Tuples are subtypes of array. They’re a special way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them. Example: . let a: [number] = [1] // A tuple of [first name, last name, birth year] let b: [string, string, number] = ['malcolm', 'gladwell', 1963] . | Usage: In TypeScript, tuples support optional elements too. Just like in object types, ? means “optional”. Tuples also support rest elements, which you can use to type tuples with minimum lengths. Not only do tuple types safely encode heterogeneous lists, but they also capture the length of the list they type. | . Enums . Enums are a way to enumerate the possible values for a type. They are unordered data structures that map keys to values. Example: . enum Language { English, Spanish, Russian } . | Usage: There are two kinds of enums: enums that map from strings to strings, and enums that map from strings to numbers. Use it when you wish to provide flexibility, making it easier to express and document intentions and use cases or when you want to save compile-time and runtime with inline code. | . Any . The any data type is the super type of all types in TypeScript. It denotes a dynamic type. Using the any type is equivalent to opting out of type checking for a variable. Example: . let a: any = 666 // any let b: any = ['danger'] // any let c = a + b // any . | Usage: In TypeScript everything needs to have a type at compile time, and any is the default type when you (the programmer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. | . Unknown . If any is the Godfather, then unknown is Keanu Reeves as undercover FBI agent Johnny Utah in Point Break: laid back, fits right in with the bad guys, but deep down has a respect for the law and is on the side of the good guys. You can compare unknown values (with ==, ===, &amp;&amp;, and ?), and refine them (like you can any other type) with JavaScript’s typeof and instanceof operators. Example: . let a: unknown = 30 // unknown let b = a === 123 // boolean . | Usage: For the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. | . Literal . In addition to standard types like boolean or number, TypeScript also supports literal types. A literal type represents a specific value, not just a general type. Example: . let e: true = true; // This is a literal type, constrained to the value true. let count: 10 = 10; // This can only ever be the number 10. let status: \"pass\" = \"pass\"; // This can only ever be the string \"pass\". These types act like constants and can only have one exact value, adding stricter type safety to your code. If you try to modify them an error will be thrown. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#types-in-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#types-in-typescript"
  },"83": {
    "doc": "TypeScript Basics",
    "title": "Variable declaration in TypeScript",
    "content": "Variables can be declared in TypeScript using one of 3 keywords: . | var: var declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this var-scoping or function-scoping. Parameters are also function scoped. Note: In modern TypeScript, you should avoid using var and prefer let or const instead. | let: When a variable is declared using let, it uses what some call lexical-scoping or block-scoping. Unlike variables declared with var whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block. | const: They are like let declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as let, but you can’t re-assign to them. Prefer const by default, and only use let when you need to reassign the variable. | . The syntax of declarations is as below: . var &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; let &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; const &lt;name&gt;: &lt;type&gt; = &lt;value&gt;; . Example: . let num: number = 1; const PI: number = 3.14; let x: string = \"This is a string\"; const t: boolean = true; const f: boolean = false; let uninitialized: any; . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#variable-declaration-in-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#variable-declaration-in-typescript"
  },"84": {
    "doc": "TypeScript Basics",
    "title": "Objects",
    "content": ". | Objects are similar to dictionaries with key-value pairs. | Arrays are iterable Objects with the keys as numbers. | . Examples: . // Avoid using 'any' type for objects const myObj: any = { key1: 'value1', key2: 'value2' }; console.log(myObj.key1); // prints 'value1' // Better: explicitly type your objects const myTypedObj: { key1: string; key2: string } = { key1: 'value1', key2: 'value2' }; console.log(myTypedObj.key1); // prints 'value1' // For reusable objects, use interfaces (covered later) interface Person { name: string; age: number; } const person: Person = { name: 'John', age: 30 }; . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#objects",
    
    "relUrl": "/tutorials/week1-typescript-basics#objects"
  },"85": {
    "doc": "TypeScript Basics",
    "title": "Control Flow Statements",
    "content": "TypeScript contains the following control flow statements: . | If-Else | Switch | Ternary operator: Shorthand for if-else which returns a value. | . If condition syntax: . if(condition) { // executed when condition is true } if(condition) { // executed when condition is true } else { // executed when condition is false } if(condition) { // executed when condition is true } else if(condition2) { // checked only if condition is false // executed when condition2 is true } else { // executed when all conditions in the if-elseif ladder are false. } . Switch case syntax: . switch (variable) { case &lt;case1&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing case &lt;case2&gt;: // executed when value of variable matches &lt;case1&gt; break; // Break is required to prevent all subsequent cases from executing default: // executed if variable does not match any prior cases } . Ternary Syntax: . let x = (condition) ? /* Executed when condition is true */ : /*Executed when condition is false*/; . Examples: . const str: string = \"ABCD\"; if(str === \"ABCD\") { console.log(\"it was true\"); } else { console.log(\"it was false\"); } switch (str) { case \"ABCD\": console.log('It was ABCD'); break; case \"WXYZ\": console.log('It was WXYZ'); break; default: console.log('It was something completely different') } let y: string = (str.includes(\"A\")) ? \"The string contains A\" : \"The string does not contain A\"; // y now contains \"The string contains A\" . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#control-flow-statements",
    
    "relUrl": "/tutorials/week1-typescript-basics#control-flow-statements"
  },"86": {
    "doc": "TypeScript Basics",
    "title": "Equality vs Strict Equality",
    "content": "TypeScript/JavaScript contain 2 equality operators: . | ==: Compares only the value of entities being compared. Performs implicit type coercions, which may lead to unexpected results. | ===: Compares the type and value of entities being compared. | . While === always compares by reference for objects and arrays, == attempts type coercion before comparison. Example: . // Evaluates to true despite comparing string to number due to type coercion. if(0 == '0') { console.log(\"String '0' is coerced to number 0\"); } if (0 == false) { console.log(\"false is coerced to 0\"); } if(0 === '0') { console.log(\"Will not print because types are different\"); } // Evaluated to false because types are different. We recommend using strict equality (===) in all cases, and this recommendation is enforced by our linter. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#equality-vs-strict-equality",
    
    "relUrl": "/tutorials/week1-typescript-basics#equality-vs-strict-equality"
  },"87": {
    "doc": "TypeScript Basics",
    "title": "Loops",
    "content": "TypeScript contains the following loops: . | For | While | Do-while | . Examples: . for(let i: number = 0; i &lt; 10; i++) { console.log(i); } while(condition) { // statements } do { // statements } while(condition) . Tips: . | Entry-Level Loops: for and while loops are entry-level loops; they evaluate their condition before executing any statements. | Exit-Level Loop: The do...while loop is an exit-level loop; it will always execute the loop body at least once, regardless of the condition. | Prefer Array Operators: When working with arrays, you should replace explicit loops with array operators like .map(), .filter(), .reduce(), and .forEach() when possible. These provide clearer, more functional code. For examples of how to use these array operators, see the Array Functions section below. | . Example of replacing a loop with array operators: . // Instead of this: const numbers = [1, 2, 3, 4, 5]; const doubled = []; for(let i = 0; i &lt; numbers.length; i++) { doubled.push(numbers[i] * 2); } // Prefer this: const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map(n =&gt; n * 2); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#loops",
    
    "relUrl": "/tutorials/week1-typescript-basics#loops"
  },"88": {
    "doc": "TypeScript Basics",
    "title": "Array Functions",
    "content": "ForEach, Map, reduce, and filter are all array methods in JavaScript. Each one will iterate over an array and perform a transformation or computation. Each will return a new array based on the result of the function. ForEach . forEach() method calls a function for each element in the array. Unlike map, filter, and reduce, forEach does not return a value. Syntax . array.forEach(callback[, thisObject]); . Example . let num = [7, 8, 9]; num.forEach(function (value) { console.log(value); }); . Map . It is an array function that transforms the array according to the applied function and returns the updated array. It works on each element of an array. Syntax . array.map(callback[,object]) . callback - It is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type - List . Examples . //Calculate cube of each element with the help of map. function cube(n){ return n*n*n; } var arr=new Array(1,2,3,4) var newArr=arr.map(cube); console.log(newArr) // Output : [1,8,27,64] . In the above example, a function called “cube” is created and then is passed as a callback function into map(). Reduce . It also works on a callback for each element of an array. It reduces the result of this callback function from one array element to the other. Syntax . array.reduce(callback[,initalValue]) . callback - this parameter is the function to execute on each value in the array. intitalValue - this parameter is the object to use as the first argument of the first call of the callback. Examples . //To calculate product of every element of an array, var arr = new Array (1,2,3,4,5) var val = arr.reduce(function(a,b){ return a*b; }); //output =&gt; 120 . Calculate the total salary from a list of object, then you will use the reduce() like, . var employees = [ { id: 20, name: 'Ajay', salary:30000 }, { id: 24, name: 'Vijay', salary:35000 }, { id: 56, name: 'Rahul', salary:32000 }, { id: 88, name: 'Raman', salary:38000 } ]; var totalSalary= employees .reduce(function (total, record) { return total + record.salary; }, 0); //It will return the total salary of all the employees. Filter . As the name suggests it can filter out the data/array elements on the basis of condition and return the result as a list. Basically, this function pushes the current element into a new array when the callback functions return true. Syntax . array.filter(callback[, object]) . callback - it is a function that provides an element of the new Array from an element of the current one. object - object to use as this when executing callback. Return Type: List . Examples . //Calculate a list of even elements from an array arr = new Array(1, 2, 3, 6, 5, 4) var newArr = arr.filter(function(record) { return record % 2 == 0; }); // output =&gt; [2,6,4] . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#array-functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#array-functions"
  },"89": {
    "doc": "TypeScript Basics",
    "title": "Functions",
    "content": ". | Functions usually “take in” data, process it, and “return” a result. Remember one function/method, one job! . | There is a lot you can do with functions in JavaScript like assign them to variables, pass them to other functions, return them from functions, assign them to objects and prototypes, write properties to them, read those properties back, and so on, and TypeScript models all of those things with its rich type system, which we just learnt. | TypeScript enables us to set the types for our function parameters and our return type. | Functions in TypeScript are defined as below: . function functionName(argument1: &lt;type&gt;, defaultArgument: &lt;type&gt; = value, optionalArgument?: &lt;type&gt;): &lt;return type&gt; { // Function body } . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#functions"
  },"90": {
    "doc": "TypeScript Basics",
    "title": "Typing the function",
    "content": "A simple function in javascript would look like this: . // Named function function add(a, b) { return a + b; } . Now, let’s add types to our simple examples above: . function add(a: number, b: number): number { return a + b; } . You will usually explicitly annotate function parameters (a and b in this example)—TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters. The return type is inferred, but it’s a good practice to explicitly annotate it. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#typing-the-function",
    
    "relUrl": "/tutorials/week1-typescript-basics#typing-the-function"
  },"91": {
    "doc": "TypeScript Basics",
    "title": "Invoking the function",
    "content": "When you invoke a function in TypeScript, you don’t need to provide any additional type information—just pass in some arguments, and TypeScript will go to work checking that your arguments are compatible with the types of your function’s parameters: . add(1, 2); // evaluates to 3 . Of course, if you forgot an argument, or passed an argument of the wrong type, TypeScript will be quick to point it out: . add(1); // Error TS2554: Expected 2 arguments, but got 1. add(1, 'a'); // Error TS2345: Argument of type '\"a\"' is not assignable // to parameter of type 'number'. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#invoking-the-function",
    
    "relUrl": "/tutorials/week1-typescript-basics#invoking-the-function"
  },"92": {
    "doc": "TypeScript Basics",
    "title": "Optional and Default Parameters",
    "content": "Like in object and tuple types, you can use ? to mark parameters as optional. When declaring your function’s parameters, required parameters have to come first, followed by optional parameters: . function log(message: string, userId?: string) { let time = new Date().toLocaleTimeString() console.log(time, message, userId || 'Not signed in') } log('Page loaded') // Logs \"12:38:31 PM Page loaded Not signed in\" log('User signed in', 'da763be') // Logs \"12:38:31 PM User signed in da763be\" . You can provide default values for optional parameters. Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do). For example, we can rewrite log as: . function log(message: string, userId = 'Not signed in') { let time = new Date().toISOString() console.log(time, message, userId) } log('User clicked on a button', 'da763be') log('User signed out') . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#optional-and-default-parameters",
    
    "relUrl": "/tutorials/week1-typescript-basics#optional-and-default-parameters"
  },"93": {
    "doc": "TypeScript Basics",
    "title": "Rest Parameters",
    "content": "This allows a function to accept a variable number of arguments by grouping them into an array. It must be the last parameter of the function. function sum(...numbers: number[]): number { return numbers.reduce((total, num) =&gt; total + num, 0); } sum(1, 2, 3); // evaluates to 6 sum(4, 5); // evaluates to 9 . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#rest-parameters",
    
    "relUrl": "/tutorials/week1-typescript-basics#rest-parameters"
  },"94": {
    "doc": "TypeScript Basics",
    "title": "Arrow Functions",
    "content": "Arrow Functions (also called fat arrow functions) are functions which have lexical ‘this’ and ‘arguments’. This are especially useful in class methods to preserve the context when using higher order functions. Examples: . let sum = (x: number, y: number): number =&gt; { return x + y; } sum(10, 20); //returns 30 . In the above example, sum is an arrow function. (x:number, y:number) denotes the parameter types, :number specifies the return type. The fat arrow =&gt; separates the function parameters and the function body. The right side of =&gt; can contain one or more code statements. Demonstrating the difference with this binding: . class Counter { count: number = 0; // Using a regular function incrementWithRegularFunction() { setTimeout(function() { this.count++; // Error: 'this' is undefined console.log(this.count); }, 1000); } // Using an arrow function incrementWithArrowFunction() { setTimeout(() =&gt; { this.count++; // 'this' refers to the Counter instance console.log(this.count); }, 1000); } } const counter = new Counter(); counter.incrementWithArrowFunction(); // Logs: 1 . In the example above, the arrow function in incrementWithArrowFunction() maintains the reference to the Counter instance, while a regular function incrementWithRegularFunction would lose the this context. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#arrow-functions",
    
    "relUrl": "/tutorials/week1-typescript-basics#arrow-functions"
  },"95": {
    "doc": "TypeScript Basics",
    "title": "Function Overloads",
    "content": "In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: . //function makeDate() with one parameter function makeDate(timestamp: number): Date; //function makeDate() with three parameters function makeDate(m: number, d: number, y: number): Date; //function makeDate() with one parameter and 2 default parameters function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); //No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#function-overloads",
    
    "relUrl": "/tutorials/week1-typescript-basics#function-overloads"
  },"96": {
    "doc": "TypeScript Basics",
    "title": "Classes",
    "content": "Classes are blueprints for creating objects. | They can contain properties, methods, and a constructor. | All members of a class can have an access modifier: public, protected, private. | Members can also be static (shared across all instances of the class) and readonly (immutable). | Class properties may have getters and setters. | Classes can extend other classes. | Classes can implement interfaces. | . Creating a Class . A class definition can include the following: . | Fields − A field is any variable declared in a class. Fields represent data pertaining to objects | Constructors − Responsible for allocating memory for the objects of the class | Functions − Functions represent actions an object can take. They are also at times referred to as methods | . Examples: . class Person { private _firstName: string = ''; protected middleName!: string; public _lastName: string = ''; private static readonly NeverGonnaGiveYouUp: any; protected static readonly NeverGonnaLetYouDown: any; public static readonly isRickRolled: boolean = true; constructor() { // I execute when you call new Person(). // No access modifier === public by default. // Make me private if implementing a singleton. } public anyoneCanCallMe(): void { this.childClassesCanCallMe(); } protected childClassesCanCallMe(): void { this.onlyAccessibleInsidePerson(); } private onlyAccessibleInsidePerson(): void { // I lied, anyone can call me if you know how. // Welcome to JavaScript :p } public get firstName(): string { return this._firstName; } public set firstName(firstname: string){ this._firstName = firstname; } } const person = new Person(); person.firstName = 'first'; console.log(person.firstName); person.anyoneCanCallMe(); class SpecialPerson extends Person { // I contain everything person has, and can extend/override it. constructor() { super() // I call the constructor for Person. } } . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#classes",
    
    "relUrl": "/tutorials/week1-typescript-basics#classes"
  },"97": {
    "doc": "TypeScript Basics",
    "title": "Creating an abstract class",
    "content": ". | Define an abstract class in TypeScript using the abstract keyword. Abstract classes are mainly for inheritance where other classes may derive from them. We cannot create an instance of an abstract class. | An abstract class typically includes one or more abstract methods or property declarations. The class which extends the abstract class must define all the abstract methods. | . Example: . abstract class Person { abstract name: string; display(): void{ console.log(this.name); } } class Employee extends Person { name: string; empCode: number; constructor(name: string, code: number) { super(); // must call super() this.empCode = code; this.name = name; } } let emp: Person = new Employee(\"James\", 100); emp.display(); //James . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#creating-an-abstract-class",
    
    "relUrl": "/tutorials/week1-typescript-basics#creating-an-abstract-class"
  },"98": {
    "doc": "TypeScript Basics",
    "title": "Type Aliases",
    "content": "We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name. A type alias is exactly that - a name for any type. The syntax for a type alias is: . type Point = { x: number; y: number; }; function printCoord(pt: Point) { console.log(\"The coordinate's x value is \" + pt.x); console.log(\"The coordinate's y value is \" + pt.y); } printCoord({ x: 100, y: 100 }); . You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type: . type ID = number | string; . Note that aliases are only aliases - you cannot use type aliases to create different/distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type: . type UserInputSanitizedString = string; function sanitizeInput(str: string): UserInputSanitizedString { return sanitize(str); } // Create a sanitized input let userInput = sanitizeInput(getInput()); // Can still be re-assigned with a string though userInput = \"new input\"; . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#type-aliases",
    
    "relUrl": "/tutorials/week1-typescript-basics#type-aliases"
  },"99": {
    "doc": "TypeScript Basics",
    "title": "Interfaces",
    "content": "Interfaces are used to define contracts for interaction with external entities. If an interface has a property/method, an Object/Class which implements it must have it. Interfaces can be used to define custom types for Objects in TypeScript. Examples: . //Interface IPerson respresents a person by attributes firstName and lastName and a method to getFullName() interface IPerson { firstName: string; lastName: string; getFullName(): string; } //Class Person implements interface Iperson. Person class must contains all the attributes and methods of interface. class Person implements IPerson { public firstName: string = ''; public lastName: string = ''; public getFullName(): string { return this.firstName + ' ' + this.lastName; } // It can contain any other properties/methods but must contain those in the interface. } const person: IPerson = new Person(); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#interfaces",
    
    "relUrl": "/tutorials/week1-typescript-basics#interfaces"
  },"100": {
    "doc": "TypeScript Basics",
    "title": "Custom types",
    "content": ". | For complicated types (usually required for Objects), it is recommended to use an interface. | Additionally, TypeScript contain the ‘type’ keyword which can be used to create new types. | This is generally used when a union of different types is required. | . Examples: . interface IStudent { name: string; age: number; studentID: number; gender: string; isEnrolled: boolean; } const student: IStudent = { name: 'name', age: 20, studentID: 111111111, gender: 'hidden', isEnrolled: true }; type StringOrNumber = string | number; let x: StringOrNumber = 1; // initialized with a `number` x = 'some string'; // can be reassigned to be a `string` . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#custom-types",
    
    "relUrl": "/tutorials/week1-typescript-basics#custom-types"
  },"101": {
    "doc": "TypeScript Basics",
    "title": "Generics",
    "content": ". | Generics allow us to pass different types to a function/class making it more generalized. | This will be especially useful when working with http requests. | . Examples: . function myFunc&lt;T&gt;(data: T): T { console.log(data); return data } let x: string = myFunc&lt;string&gt;('some string'); let y: number = myFunc&lt;number&gt;(5); class myClass&lt;T&gt; { } interface IMyInterface&lt;T&gt; { } . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#generics",
    
    "relUrl": "/tutorials/week1-typescript-basics#generics"
  },"102": {
    "doc": "TypeScript Basics",
    "title": "Modules",
    "content": "Each TypeScript file in our project is a separate JavaScript module. By default nothing defined in one module can be used in another module. | export makes the variables and functions from a module visible outside it. | import allows us to use variables and functions exported by another module. | . There are two ways of exporting from a JavaScript or TypeScript module: adding export before the functions declaration (like add and someVar in the example below), and writing a separate export statemen (like subtract in the example below: . // file1.ts export interface Message { msg: string } export function add(x: number, y: number): number { return x + y; } function subtract(x: number, y: number): number { return x - y; } export const someVar: Message = { msg: 'Variables can be exported too.' }; function multiply(): void { throw new Error(); } export { subtract }; . Import statements allow exported parts of one module to be used in another module. Imported TypeScript types need to be prefixed with type. // file2.ts import { add, someVar, subtract, type Message } from './file1.ts'; add(1, 2); subtract(2, 1); console.log(someVar); const myMessage: Message = { msg: 'Hello' }; console.log(myMessage); . Default Imports . A module can have at most one default export. The default export is marked with the default keyword after export. // file3.ts export default function addOne(x: number): number { return x + 1; } export function addTwo(x: number): number { return x + 2; } . A default export is imported without the curly braces: . // file4.ts import addOne from './file3.ts'; import { addTwo } from './file3.ts'; addOne(41); addTwo(65); . It’s possible to combine default and non-default imports into a single line: . // file4.ts import addOne, { addTwo } from './file3.ts'; addOne(41); addTwo(65); . In React projects, the single React component exported from a file is usually a default export. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#modules",
    
    "relUrl": "/tutorials/week1-typescript-basics#modules"
  },"103": {
    "doc": "TypeScript Basics",
    "title": "Object oriented programming concepts using TypeScript",
    "content": "Object Oriented Programming or OOP is a programming paradigm that has four principles which are: . | Inheritance | Polymorphism | Abstraction | Encapsulation | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#object-oriented-programming-concepts-using-typescript",
    
    "relUrl": "/tutorials/week1-typescript-basics#object-oriented-programming-concepts-using-typescript"
  },"104": {
    "doc": "TypeScript Basics",
    "title": "Inheritance",
    "content": "TypeScript supports the concept of inheritance. Inheritance is the ability of a program to create new classes from an existing class. The class that is extended to create newer classes is called the parent class/super class. The newly created classes are called the child/sub classes. A class inherits from another class using the ‘extends’ keyword. Child classes inherit all properties and methods except private members and constructors from the parent class. However, TypeScript doesn’t support multiple inheritance. Syntax: . class child_class_name extends parent_class_name . Example: . //Parent class Shape class Shape { Area:number constructor(a:number) { this.Area = a } } //Child class Circle that inherits properties of Shape class Circle extends Shape { disp():void { console.log(\"Area of the circle: \"+this.Area) } } var obj = new Circle(223); obj.disp() . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#inheritance",
    
    "relUrl": "/tutorials/week1-typescript-basics#inheritance"
  },"105": {
    "doc": "TypeScript Basics",
    "title": "Polymorphism",
    "content": "When multiple classes inherit from a parent and override the same functionality, the result is polymorphism. Each of those child classes now implements a property or method, but they each may have their own way of performing that implementation. Alternatively, one child class might override the parent’s members while another child doesn’t but just accepts the parent class’s implementation instead. This also demonstrates polymorphic behavior, since those behaviors are different between the siblings. class CheckingAccount { open(initialAmount: number) { // code to open account and save in database } } class BusinessCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt; 1000) { throw new Error(\"Business accounts must have an initial deposit of 1.000 Euros\") } super.open(initialAmount); } } class PersonalCheckingAccount extends CheckingAccount { open(initialAmount: number) { if (initialAmount &lt;= 0) { throw new Error(\"Personal accounts must have an initial deposit of more than zero Euros\") } super.open(initialAmount); } } . In the above code sample, the two child classes have different business rules to implement when it comes to opening an account – mainly different opening balances. Because both children have a method to open the account but both children choose to do it differently means the behavior is polymorphic. To achieve polymorphism, inherit from a base class, then override methods and write implementation code in them. In addition to overriding methods, you can overload methods to achieve polymorphism. Overloaded methods are methods that have different signatures (i.e., different data types or number of arguments) with the same name. However, in TypeScript, methods aren’t overloaded by simply modifying the types or number of arguments like in some other languages. To create an overload in TypeScript, you can either add optional arguments to a method, or overload function declarations in an interface and implement the interface. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#polymorphism",
    
    "relUrl": "/tutorials/week1-typescript-basics#polymorphism"
  },"106": {
    "doc": "TypeScript Basics",
    "title": "Abstraction",
    "content": "Abstraction is a way to model objects in a system that creates a separation of duties between class or type and the code that inherits it. A developer creates a type, i.e., a class or interface, and that type specifies what the calling code should implement, but not how. So it’s the job of the abstract type to define what needs to be done, but up to the consuming types to actually do those things. To enforce abstraction, inherit or implement from abstract classes and interfaces. For example, some bank accounts have fees. You can create a Fee interface that defines a method for charging a fee. Fees don’t apply to all types of accounts, so it’s best to create an interface that can be applied to specific classes anywhere in the inheritance hierarchy. A checking account might charge fees, where its parent and sibling, the generic bank account and savings accounts might not. interface Fee { chargeFee(amount: number ); } // parent BankAccount and sibling SavingsAccount do not implement Fee interface class BankAccount { ... } class SavingsAccount extends BankAccount { ... } // checking implements Fee class CheckingAccount extends BankAccount implements Fee { chargeFee(amount: number) {} } . Children classes inherit interface members that have been implemented in their parent, so if a BusinessChecking account has inherited from the CheckingAccount class, then it inherits that implementation. // BusinessChecking inherits CheckingAccount and therefore Fee class BusinessChecking extends CheckingAccount { … } // Code that uses BusinessChecking can call chargeFee function CalculateMonthlyStatements() { let businessChecking = new BusinessChecking(); businessChecking.chargeFee(100); } . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#abstraction",
    
    "relUrl": "/tutorials/week1-typescript-basics#abstraction"
  },"107": {
    "doc": "TypeScript Basics",
    "title": "Encapsulation",
    "content": "Encapsulation is a key part of Object Oriented Programming that is a way to structure code so that a certain block of code has specific access points for external code. The term for this is “visibility” or “accessibility”. Visibility defines what code from one method, property, or class can call code in another method, property, or class. In TypeScript, we enforce encapsulation with methods and properties that only allow access to data that we control. The Withdraw method below does that by doing the calculation and updating the class level _balance field. The Balance property then returns the private _balance field to the calling code. Withdraw(amount: number): boolean { if (this._balance &gt; amount) { this._balance -= amount return true; } return false; } private _balance: number; get Balance(): number { return this._balance; } . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#encapsulation",
    
    "relUrl": "/tutorials/week1-typescript-basics#encapsulation"
  },"108": {
    "doc": "TypeScript Basics",
    "title": "General Guidelines",
    "content": ". | Naming conventions . | use kebab-case for file names. | Use camelCase for variable and function names. | Use PascalCase for Class and constructor function names. | . | Prefer descriptive names over random letters. | Although typing is optional in TypeScript, it is not optional for this course. | Always use strict equality. | Use a linter. (as specified on course website) | Use a prettifier. (If the linter doesn’t do it already) | Use general coding guidelines as discussed in Week1. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#general-guidelines",
    
    "relUrl": "/tutorials/week1-typescript-basics#general-guidelines"
  },"109": {
    "doc": "TypeScript Basics",
    "title": "The tsconfig.json file",
    "content": "The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project, and sets various options for TypeScript. Some of these options control how whether or not TypeScript will report certain kinds of errors. The noImplicitAny option, for example, causes TypeScript to complain about certain uses of the any type, and the strict option sets a lot of other options, including noImplicitAny. Other options control what TypeScript does when it is run. The noEmit option, for example, configures TypeScript to work only as a type checker. If this option is disabled, the TypeScript compiler will output compiled JavaScript files that match the TypeScript files. There are many more options that configure TypeScript to work with different kinds of projects. A web server that runs directly in Node.js needs to be configured differently than a React project using JSX that runs in the web browser, for example. All of TypeScript’s configuration options can be found in the TSConfig Reference, but you should not need to manipulate TypeScript’s configuration much in this class. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-typescript-basics#the-tsconfigjson-file",
    
    "relUrl": "/tutorials/week1-typescript-basics#the-tsconfigjson-file"
  },"110": {
    "doc": "Unit Testing with Vitest",
    "title": "Understanding Unit Testing",
    "content": "At some point, every programmer has wondered why they should spend time writing test cases instead of focusing on implementing a new feature. The reason for this is that it is important! In this tutorial, we’ll go through several aspects of unit testing, with a focus on utilizing Vitest. Before we get into that, let’s define unit testing and why it’s so important in the real world. Unit testing is not a new concept; it has been around for a long time. “Unit tests are often automated tests prepared and executed by software engineers to check that a portion of an application (referred to as a “unit”) matches its design and behaves as expected,” according to Wikipedia. So, to put it another way, it’s a technique to undertake rigorous testing of every single function/module in isolation. Unit testing techniques: . | Black Box Testing : It is a process of validating a function’s input and output without any knowledge of its internal implementation details. | White Box Testing : Unlike Black Box testing, white box testing focuses on testing the specific internal code flows, uncovering any unidentified error or bug in that component. | Gray Box Testing : Gray Box testing is a combination of the two above wherein partial knowledge of the internal code is needed. This strategy lowers a tester’s reliance on a developer for every minor issue, allowing the tester to detect and resolve it alone. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#understanding-unit-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#understanding-unit-testing"
  },"111": {
    "doc": "Unit Testing with Vitest",
    "title": "Testing with Vitest",
    "content": " ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#testing-with-vitest",
    
    "relUrl": "/tutorials/week1-unit-testing#testing-with-vitest"
  },"112": {
    "doc": "Unit Testing with Vitest",
    "title": "Basics",
    "content": "To understand the basics of unit testing, let us look at the file called ‘calculator.ts’ present in the directory src/services/math/. This file contains a class called Calculator with a method for add() defined as shown below: . // Contents of src/services/math/calculator.ts export default class Calculator { public add(num1: number, num2: number): number { const result: number = num1 + num2; console.log(\"The result is: \", result); return result; } } . Let us write some tests for this code using Vitest. The test code will go into a file in the same directory titled ‘calculator.test.ts’. Create this file now. This pattern of ‘file-name.test.ts’ is how you should name all of your test files when using Vitest. All test files start with a suite. A suite is a collection of tests (or a logical grouping of tests). In Vitest, a suite is created by using the function describe(). The suite takes 2 arguments: the 1st being the description of the suite and the second being a callback function. Additionally, suites can be nested to form logical groups. Suites can further be broken down into 3 components that we will explore in detail shortly: . | Setup | Teardown | Test | . Syntax: . describe(\"Description of suite\", () =&gt; { // The tests go here. }); . Suites can be used to make debugging easier when you are using a large number of tests. Here is one recommended suite hierarchy: . | Top level describe should contain the file path after src. | Second describe should contain the name of the Class/File being tested. | Subsequent describe blocks should contain the name of the function being tested. | . Using this hierarchy, the test file for the above example would look as follows: . describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { // Tests for add() go here. }); }); }); . Specs . A spec is an actual test that executes some code and asserts some result. A test is created using the keyword it() or test(). Similar to describe(), it() takes 2 arguments, the first being the description of the test and the second being a callback. Generally, we want to describe what the code should do in the description of it() and assert the described behavior within the test. Each test can be broken down into 3 parts (Assemble, Act, Assert) which makes up the AAA pattern. Optionally, there may be a clean-up/teardown step after the assert. Syntax: . it(\"should check a specific behavior\", () =&gt; {}); . Let us write a simple test for our add() method to check 1 + 1 = 2. We start by adding a spec to the suite we created previously. describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { // Assemble // Act // Assert }); }); }); }); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#basics",
    
    "relUrl": "/tutorials/week1-unit-testing#basics"
  },"113": {
    "doc": "Unit Testing with Vitest",
    "title": "Matchers",
    "content": ".toEqual() vs .toBe() vs .toStrictEqual() . All three matchers are used to test equality, though they have slight but important differences. To understand these differences, let us take a look at the example of Store.ts with the below code. export default class Store { private static _data: any = null; public static getData(): any { return Store._data; } public static setData(data: any): void { Store._data = data; } } . | Use .toEqual() to compare recursively all properties of object instances (also known as “deep” equality). It calls Object.is to compare primitive values, which is even better for testing than ‘===’, the strict equality operator. This is the most commonly used matcher. | . import { describe, it, expect, beforeEach } from 'vitest'; describe(\"utils &gt; store\", () =&gt; { describe(\"Store\", () =&gt; { beforeEach(() =&gt; { Store[\"_data\"] = undefined; }); describe(\"setData()\", () =&gt; { it(\"should assign the input data to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store.setData(mockData); expect(Store[\"_data\"]).toEqual(mockData); }); }); describe(\"getData()\", () =&gt; { it(\"should return an object equal to Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); }); }); }); }); . | Use .toBe() to compare primitive values or to check referential identity of object instances. It calls Object.is to compare values, which is even better for testing than ‘===’, the strict equality operator. | . describe(\"getData()\", () =&gt; { it(\"should return an object with the same reference as Store._data\", () =&gt; { const mockData = { key: \"value\" }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toEqual(mockData); expect(returnedValue).toBe(mockData); // Same reference expect(Store[\"_data\"]).toBe(mockData); }); }); . | Use .toStrictEqual() to test that objects have the same types as well as structure. This checks for undefined in Objects and sparseness in Arrays. | { key: undefined } is not strictly equal to { }. | [ , 1] is not strictly equal to [undefined, 1]. | . | . it(\"should return an object strictly equal to object stored in Store._data\", () =&gt; { const mockData = { key: \"value\" }; const mockDataWithUndefined = { key: \"value\", key2: undefined }; Store[\"_data\"] = mockData; const returnedValue = Store.getData(); expect(returnedValue).toStrictEqual(mockData); expect(returnedValue).toEqual(mockDataWithUndefined); expect(returnedValue).not.toStrictEqual(mockDataWithUndefined); }); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#matchers",
    
    "relUrl": "/tutorials/week1-unit-testing#matchers"
  },"114": {
    "doc": "Unit Testing with Vitest",
    "title": "AAA",
    "content": "The AAA pattern stands for Assemble-Act-Assert. You may also see this referred to as Assemble-Act-Assess in some materials (including lecture slides), as one typically assesses code behavior using assert statements. Both terms are used interchangeably in practice. Assemble . In order to run a test, we need to first assemble it. This may include creating instances of classes/variables, setting up test data for inputs, setting up spies/stubs/mocks (which will be covered in subsequent sections), or setting up the expected output. In simple cases, one may not need to assemble the test. This phase is very similar to the setup phase. In our example, let us create an instance of the Calculator class as part of assembling the test. import { describe, it, expect } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); // Act // Assert }); }); }); }); . Act . In this step, we actually execute the function under test with required inputs and get the returned result (if any). In our example, we will invoke the add() method with inputs (1, 1) and get the result. import { describe, it, expect } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); // Assert }); }); }); }); . Assert . Assertion is a statement that validates the behavior of our code by comparing the actual result against the expected results. There are many assertions provided by Vitest, including some useful assertions we will use throughout our tests. Some of these assertions are listed below: . | expect(actual).toEqual(expected) // Expects both entities to have the same value. | expect(actual).toBe(expected) // Expects both entities to be the same. | expect(spy/stub/mock).toHaveBeenCalled() // Expects a function being spied/stubbed/mocked to be invoked. | expect(spy/stub/mock).toHaveBeenCalledWith([arguments]) // Expects a function being spied/stubbed/mocked to be invoked with specified arguments. | expect(actual).toBeDefined() // Expects the entity to be defined. | expect(actual).not. // Negates the assertion. Can be chained with any matchers above | await expect(error causing code returning a promise).rejects.toThrowError() // Waits for the error throwing code that returns promise (e.g. an API call) to throw the error and asserts the error was thrown. | . A full list of matchers can be found here. In our example, we can use the .toEqual() matcher. import { describe, it, expect } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const calculator: Calculator = new Calculator(); const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#aaa",
    
    "relUrl": "/tutorials/week1-unit-testing#aaa"
  },"115": {
    "doc": "Unit Testing with Vitest",
    "title": "Setup and Teardown",
    "content": "Often in tests, we need some things to happen before a test actually runs and some things to happen after it. This may include resetting/initializing values, setting up test data, setting up spies/stubs/mocks, cleaning up variables after a test, or resetting spies/stubs/mocks. Sometimes these steps may need to be repeated for each test. This is where the setup and teardown can be especially useful. Vitest Provides 2 methods for setup and 2 methods for teardown: . | beforeAll(): Runs one time before all the tests in a suite. | beforeEach(): Runs before every test in a suite. | afterEach(): Runs after every test in a suite. | afterAll(): Runs once after all tests in a suite. | . In our example, notice we created an instance of calculator in our Assemble phase. We will probably have multiple tests for the calculator that will require this instance. In order to avoid repeating this in every step, let us move this to the setup phase and add a teardown to clear this after all tests. Note: Use beforeEach()/afterEach() if the function/class stores state, and we need a clean instance for each test. In our case, calculator does not store any state, and we can share the same instance across tests with out any side effects. Hence, we will use beforeAll()/afterAll(). import { describe, it, expect, beforeAll, afterAll } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); }); }); }); . Let us add another test to cover a different scenario, such as adding negative numbers. import { describe, it, expect, beforeAll, afterAll } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should return 2 when inputs are 1 and 1\", () =&gt; { const result: number = calculator.add(1, 1); expect(result).toEqual(2); }); it(\"should return -2 when inputs are -1 and -1\", () =&gt; { const result: number = calculator.add(-1, -1); expect(result).toEqual(-2); }); }); }); }); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#setup-and-teardown",
    
    "relUrl": "/tutorials/week1-unit-testing#setup-and-teardown"
  },"116": {
    "doc": "Unit Testing with Vitest",
    "title": "Mock Testing",
    "content": "As a project grows so do the interdependencies in the project. A function under test can have dependencies from various external entities. This may include other functions, network requests, database connections, or built-in connections. Spies, Stubs, and Mocks are ways of dealing with such external dependencies. You can read more on what you can do with spies/stubs/mocks here. Spy . A spy is a watcher on a function that tracks various properties of the function being spied on. This can return information such as whether a function was invoked, how many times it was invoked, and what argument it was invoked with. A spy on a function is created using the syntax const spy = vi.spyOn(object, 'methodName'); . Note: The function being spied on actually executes. In our example, we have an external dependency on console.log(). Let us add a spy and test for it. import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest'; import Calculator from \"./calculator\"; describe(\"services &gt; math\", () =&gt; { describe(\"Calculator\", () =&gt; { describe(\"add()\", () =&gt; { let calculator: Calculator; beforeAll(() =&gt; { calculator = new Calculator(); }); afterAll(() =&gt; { (&lt;any&gt;calculator) = undefined; }); it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = vi.spyOn(console, \"log\"); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); }); }); }); . Mock . A mock is a function which replaces an existing function. In our example, if we wanted to change the behavior of console.log() for our tests, we can do so using a mock. A mock implementation can be substituted for a spy or a vi.fn(). The syntax is as below: . spy.mockImplementation(() =&gt; { // new function body goes here. }); . Note: The function being mocked does not execute. In our example, if we wanted to replace the behavior of console.log(), we can do so as shown: . it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = vi.spyOn(console, \"log\"); logSpy.mockImplementation(() =&gt; { // This will no longer print to console. }); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . Warning: Watch out for circular dependencies in mock implementations. Stub . A stub is a special kind of mock which does not require an alternate implementation but instead returns some value that we specify. When a stub gets invoked, it does not invoke the actual function, but returns the desired value instead. The syntax is as below: . spy.mockReturnValue(someValue); . To return a promise, we can use: . spy.mockResolvedValue(someValue); . This can be especially handy when stubbing Axios requests. Using a stub in our example simply prevents console.log() from being executed, since it does not return a value anyway. it(\"should invoke console.log() with the result 2 for inputs 1 and 1\", () =&gt; { const logSpy = vi.spyOn(console, \"log\"); logSpy.mockReturnValue(); const result: number = calculator.add(1, 1); expect(logSpy).toHaveBeenCalledWith(\"The result is: \", result); logSpy.mockRestore(); }); . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#mock-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#mock-testing"
  },"117": {
    "doc": "Unit Testing with Vitest",
    "title": "Testing Asynchronous Code",
    "content": "Promise . In previous tutorials, we have used Axios to make http requests which return promises. This is how we can write tests for axios requests. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } } . We can test the above code as follows: . // Assuming we have done the setup as in previous tests import { describe, it, expect, vi } from 'vitest'; describe(\"getData()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = vi .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getData(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should return the status as 200\", async () =&gt; { const getStub = vi .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); const response = await httpService.getData(); expect(response.status).toEqual(200); getStub.mockRestore(); }); }); . Testing Promise Rejections . When testing async functions that are expected to throw errors or reject promises, you need to use await expect(...).rejects.toThrowError(). This is a common source of bugs in tests — if you forget to use the correct pattern, your test may pass even when the code doesn’t behave as expected. Consider a function that validates user authentication: . export async function enforceAuth(credentials: { username: string; password: string }): Promise&lt;{ _id: string; username: string }&gt; { const user = await validateCredentials(credentials); if (!user) { throw new Error('Invalid credentials'); } return { _id: user.id, username: credentials.username }; } . We can test both successful authentication and failed authentication as follows: . import { describe, it, expect } from 'vitest'; import { enforceAuth } from '../../src/services/auth.service'; describe('enforceAuth', () =&gt; { it('should return a user and id on good auth', async () =&gt; { const user = await enforceAuth({ username: 'user1', password: 'pwd1111' }); expect(user).toStrictEqual({ _id: expect.any(String), username: 'user1' }); }); it('should raise on bad auth', async () =&gt; { await expect(enforceAuth({ username: 'user1', password: 'no' })).rejects.toThrowError(); }); }); . Important: Notice the pattern for testing rejections: . | The test function must be async | You must await the expect() call | Use .rejects.toThrowError() to assert that the promise rejects with an error | . A common mistake is writing the test like this (which won’t work correctly): . // ❌ INCORRECT - This test will pass even if the function doesn't throw! it('should raise on bad auth', () =&gt; { expect(() =&gt; enforceAuth({ username: 'user1', password: 'no' })).toThrow(); }); . The correct pattern ensures the test properly waits for the async rejection: . // ✅ CORRECT - Properly tests async rejection it('should raise on bad auth', async () =&gt; { await expect(enforceAuth({ username: 'user1', password: 'no' })).rejects.toThrowError(); }); . Note: You can return different values for subsequent calls to a stub. Occasionally, you may run into situations where an http request is made but no promise is returned. This is often found in cases involving “fire and forget” calls or a central store with an Observable pattern implementation (e.g. Redux with react). We cannot await a function that does not return a promise. However, we can use fake timers to simulate passage of time to test such asynchronous behavior. Consider the example below: . import axios from \"axios\"; import Store from \"../../utils/store/store\"; export default class HttpService { public getData(): Promise&lt;any&gt; { return axios.get(\"/myUrl\"); } public getDataAndSetStore(): void { axios.get(\"/myUrl\").then((res) =&gt; { Store.setData(res.data); }); } } . We can test the above functionality as follows: . describe(\"getDataAndSetStore()\", () =&gt; { it('should invoke axios.get() with \"myUrl\"', async () =&gt; { const getStub = vi .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: {} }); await httpService.getDataAndSetStore(); expect(getStub).toHaveBeenCalledWith(\"/myUrl\"); }); it(\"should set the data in store\", async () =&gt; { const addDataStub = vi.spyOn(Store, \"setData\").mockImplementation(); const getStub = vi .spyOn(axios, \"get\") .mockResolvedValue({ status: 200, data: \"myData\" }); vi.useFakeTimers(); httpService.getDataAndSetStore(); vi.runAllTimers(); await Promise.resolve(); expect(addDataStub).toHaveBeenCalledWith(\"myData\"); addDataStub.mockRestore(); getStub.mockRestore(); vi.useRealTimers(); }); }); . You can read more about Vitest timers here. Callbacks . Callbacks are one of the most commonly used patterns for asynchronous programming in JavaScript/TypeScript. Consider the below callback function use case: . test('Check if I am a true husky', () =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); } fetchData(callback); }); . Here, fetchData() is a function that takes a callback and would call that callback function later in its implementation. Now consider 2 scenarios: . case 1: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am from Northeastern!'); }, 1000); } . case 2: . fetchData(callback) { setTimeout(()=&gt;{ callback('I am not from Northeastern!'); }, 1000); } . The test case would still pass in either of the above scenarios since fetchData() is an async function, which means the program will not wait for the call to complete. The correct way to test a callback would be using the argument done in the test like shown in below example: . test('Check if I am a true husky', (done) =&gt; { function callback(data) { expect(data).toBe('I am from Northeastern!'); done(); } fetchData(callback); }); . Now, the program would wait for done to be invoked. This implementation would correctly test both the above scenarios. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#testing-asynchronous-code",
    
    "relUrl": "/tutorials/week1-unit-testing#testing-asynchronous-code"
  },"118": {
    "doc": "Unit Testing with Vitest",
    "title": "UI Testing",
    "content": "Testing UIs can be very tricky, especially when we want to test features involving user interaction (e.g. a user clicking on a button). However, there are some useful tools that can help us. The React Testing Library provides many helpful features that can help us. import {render, screen} from '@testing-library/react' import Counter from './Counter' it('renders the Counter component correctly', async () =&gt; { render(&lt;Counter /&gt;); // Will throw error if not found screen.getByText(\"Count: 0\") screen.getByText(\"Click me!\") }) . Above is a very simple test to ensure that our Counter component renders as expected without any user input. Suppose now that we wanted to test user interaction with the page: . import {render, fireEvent, screen} from '@testing-library/react' import Counter from './Counter' it('correctly renders the updated count after the user clicks the button', async () =&gt; { render(&lt;Counter /&gt;); screen.getByText(\"Count: 0\") fireEvent.click(screen.getByRole('button')) screen.getByText(\"Count: 1\") }) . A full list of testing functions from React Testing Library can be found here. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#ui-testing",
    
    "relUrl": "/tutorials/week1-unit-testing#ui-testing"
  },"119": {
    "doc": "Unit Testing with Vitest",
    "title": "Setting up testing using Vitest in VSCode",
    "content": "Testing can sometimes get cumbersome as the user is expected to remember all the options provided by Vitest to run a specific set of tests, or otherwise the user will have to run the entire test suite just to verify the result of a single test case. Not anymore! . With the official Vitest extension, you have complete control over the way you want to run tests, with many features that visually inform the users about which specific line is failing with what error. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#setting-up-testing-using-vitest-in-vscode",
    
    "relUrl": "/tutorials/week1-unit-testing#setting-up-testing-using-vitest-in-vscode"
  },"120": {
    "doc": "Unit Testing with Vitest",
    "title": "Features",
    "content": ". | Run, debug, and watch tests directly in Visual Studio Code | Inline test results - Show individual pass/fail status next to each test | Error highlighting - Highlights errors next to the expect functions | Inline console.log display - Console logs appear inline in the editor next to the code that produced them | Coverage support - Run tests with code coverage (requires VS Code &gt;= 1.88) | Continuous run mode - Watch mode for running tests on file changes | Test filtering - Use @open tag to only show tests open in the editor | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#features",
    
    "relUrl": "/tutorials/week1-unit-testing#features"
  },"121": {
    "doc": "Unit Testing with Vitest",
    "title": "Requirements",
    "content": ". | Visual Studio Code version &gt;= 1.77.0 | Vitest version &gt;= v1.4.0 | Node.js version &gt;= 18.0.0 | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#requirements",
    
    "relUrl": "/tutorials/week1-unit-testing#requirements"
  },"122": {
    "doc": "Unit Testing with Vitest",
    "title": "Installation",
    "content": "Direct Installation . | Open Visual Studio Code and go to the Extensions tab (Cmd+Shift+X on macOS, Ctrl+Shift+X on Windows/Linux). | Search for “Vitest” (publisher: “Vitest”). | Click “Install”. | . From Visual Studio Marketplace . | Visit Vitest - Visual Studio Marketplace and click “Install”. | Allow the browser to open VSCode. | Once VSCode is open, click “Install”. | . Once installed, the extension should work out of the box without any extra configuration for most projects with Vitest configured. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#installation",
    
    "relUrl": "/tutorials/week1-unit-testing#installation"
  },"123": {
    "doc": "Unit Testing with Vitest",
    "title": "Verifying Installation",
    "content": "After installation (VSCode restart may be required): . | Open the Testing view by clicking the flask/beaker icon in the Activity Bar (left sidebar), or open the Command Palette (Cmd+Shift+P / Ctrl+Shift+P) and run “Testing: Focus on Test Explorer View”. | You should see your test files and test suites listed in the Test Explorer. | Green checkmarks indicate passing tests, red X marks indicate failures. | . If tests don’t appear, open the Command Palette (Cmd+Shift+P / Ctrl+Shift+P) and run “Vitest: Start All Runners”. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#verifying-installation",
    
    "relUrl": "/tutorials/week1-unit-testing#verifying-installation"
  },"124": {
    "doc": "Unit Testing with Vitest",
    "title": "Project Configuration",
    "content": "For the extension to work, your project needs Vitest configured. Create a vitest.config.ts file in your project root: . import { defineConfig } from 'vitest/config'; export default defineConfig({ test: { globals: true, environment: 'node', include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'], } }); . Add test scripts in your package.json: . { \"scripts\": { \"test\": \"vitest\", \"test:watch\": \"vitest --watch\", \"test:coverage\": \"vitest --coverage\" } } . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#project-configuration",
    
    "relUrl": "/tutorials/week1-unit-testing#project-configuration"
  },"125": {
    "doc": "Unit Testing with Vitest",
    "title": "Using the Extension",
    "content": "Running Tests from the Testing View . The Testing view in the sidebar provides a tree view of all your tests: . | Run All Tests: Click the play button at the top to run all tests | Run Single Test/Suite: Hover over a test or suite and click the play button | Run Tests with Coverage: Click the coverage icon to run tests with code coverage | Continuous Run: Click the “eye” icon to enable watch mode - tests will rerun when files change | . Running Tests from Test Files . When viewing a test file, you’ll see icons in the gutter (left margin) next to each test: . | Click the icon to run that specific test | Right-click the icon for more options: . | Run Test - Execute the test | Debug Test - Start a debugging session | Run with Coverage - Run with code coverage | Reveal in Test Explorer - Find the test in the Testing view | . | . Keyboard Shortcuts . VS Code provides testing commands you can access via the Command Palette (Cmd+Shift+P / Ctrl+Shift+P): . | Test: Run All Tests - Run all tests in the workspace | Test: Run Test at Cursor - Run the test at the current cursor position | Test: Rerun Last Run - Re-run the last executed tests | Test: Debug Test at Cursor - Debug the test at the current cursor position | . You can also view and customize keyboard shortcuts for these commands by opening the Keyboard Shortcuts editor (Cmd+K Cmd+S / Ctrl+K Ctrl+S) and searching for “test”. ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#using-the-extension",
    
    "relUrl": "/tutorials/week1-unit-testing#using-the-extension"
  },"126": {
    "doc": "Unit Testing with Vitest",
    "title": "Debugging Tests",
    "content": "The Vitest extension makes debugging tests straightforward: . | Set Breakpoints: Click in the gutter (left of line numbers) to set breakpoints in your test or source code. | Start Debugging: . | Right-click on the test icon in the gutter and select “Debug Test” | Or hover over a test in the Testing view and click the debug icon (bug icon) | . | Use the Debugger: When the debugger pauses at a breakpoint: . | Hover over variables to see their values | Use the Debug Console to evaluate expressions | Step through code using the debug toolbar (Step Over, Step Into, Step Out) | . | Debug Configuration: The extension automatically configures debugging. If you need custom settings, you can modify these in your VS Code settings: . | vitest.debuggerPort - Port for the debugger (default: 9229) | vitest.debugExclude - Glob patterns to exclude from debugging | . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#debugging-tests",
    
    "relUrl": "/tutorials/week1-unit-testing#debugging-tests"
  },"127": {
    "doc": "Unit Testing with Vitest",
    "title": "Extension Settings",
    "content": "You can customize the extension behavior in VS Code settings (Cmd+, / Ctrl+,): . | Setting | Description | Default | . | vitest.rootConfig | Path to your Vitest config file | Auto-detected | . | vitest.nodeExecutable | Path to Node.js executable | Auto-detected | . | vitest.showImportsDuration | Show module import times | true | . | vitest.applyDiagnostic | Show error squiggly lines | true | . For Monorepo Projects . If you’re working with a monorepo, configure a Vitest workspace: . | Create a vitest.workspace.ts file at the root: | . import { defineWorkspace } from 'vitest/config'; export default defineWorkspace([ 'packages/*/vitest.config.ts', ]); . | Set the workspace config in VS Code settings: { \"vitest.workspaceConfig\": \"./vitest.workspace.ts\" } . | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#extension-settings",
    
    "relUrl": "/tutorials/week1-unit-testing#extension-settings"
  },"128": {
    "doc": "Unit Testing with Vitest",
    "title": "Troubleshooting",
    "content": "Tests not appearing in Test Explorer: . | Ensure Vitest is installed (npm install -D vitest) | Check that your config file is named correctly (vitest.config.ts or vite.config.ts) | Run “Vitest: Start All Runners” from the Command Palette | . Extension not finding Vitest: . | Set vitest.vitestPackagePath to the path of Vitest’s package.json in your node_modules | . Debugging not working: . | Ensure source maps are enabled in your config | Check that the vitest.debuggerPort is not in use | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#troubleshooting",
    
    "relUrl": "/tutorials/week1-unit-testing#troubleshooting"
  },"129": {
    "doc": "Unit Testing with Vitest",
    "title": "General Guidelines For Writing Tests",
    "content": "Note: The following will be used as a reference when grading assignments. | Tests should be hermetic. | Reduce flakiness. | Flaky tests are those that fail intermittently: . | Nondeterminism (e.g., hash codes, random numbers); | Timing issues (e.g., threads, network). | Availability of Resources | . | . | Tests should be clear. | After failure, should be clear what went wrong. | . | Tests should be scoped as small as possible. | Faster and more reliable. | . | Tests should make calls against public APIs. | Or they become brittle | Brittle tests are those that are not self-contained: . | Ordering of tests (e.g., assume prior state) | . | . | . Note: The following will not be used as a reference when grading assignments. But you should try following these guidelines as much as you can. | Write tests based on the expected behavior, not based on the interpretation/implementation of it. | Test assertion (expect) should match the test description. | Each spec should test only 1 thing (preferably with 1 assertion per test). | Organize tests using suites (i.e. each method has its own suite). | Use setup and teardown functions to reduce code duplicity. | Code duplicity in tests is preferred over complicated logic to reduce it. | If your tests need tests, they have no value. | . | Cover the happy path for your code first. | Follow up with edge cases. | End with error scenarios. | . | Mock/Stub all external dependencies. | Clear the mocks after each test. | . | If large test data is being used, ensure clean-up after tests to prevent memory leaks. | Code coverage is a deceptive measure. 100% coverage does not mean 100% tested code. | A well designed test suite improves the quality and reliability of code. | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing#general-guidelines-for-writing-tests",
    
    "relUrl": "/tutorials/week1-unit-testing#general-guidelines-for-writing-tests"
  },"130": {
    "doc": "Unit Testing with Vitest",
    "title": "Unit Testing with Vitest",
    "content": "This tutorial covers the basics on unit testing with Vitest. By the end of this tutorial, you will have an introduction to unit testing with Vitest, best practices, and some handy tricks and tips to use in your tests. Note: Run npm i on the handouts before proceeding to update/run the tests. Contents: . | Understanding Unit Testing | Testing with Vitest . | Basics . | Specs | . | Matchers . | .toEqual() vs .toBe() vs .toStrictEqual() | . | AAA . | Assemble | Act | Assert | . | Setup and Teardown | Mock Testing . | Spy | Mock | Stub | . | Testing Asynchronous Code . | Promise | Testing Promise Rejections | Callbacks | . | UI Testing | . | Setting up testing using Vitest in VSCode . | Features | Requirements | Installation . | Direct Installation | From Visual Studio Marketplace | . | Verifying Installation | Project Configuration | Using the Extension | Debugging Tests | Extension Settings | Troubleshooting | . | General Guidelines For Writing Tests | . ",
    "url": "/CS4530-Spring-2026/tutorials/week1-unit-testing",
    
    "relUrl": "/tutorials/week1-unit-testing"
  }
}
